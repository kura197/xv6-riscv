0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 
0204 #define PHYSTOP 0x800000           
0205 
0206 
0207 
0208 #define DEVSPACE 0xFFFFF000         
0209 
0210 
0211 #define KERNBASE 0x80000000         
0212 #define KERNLINK (KERNBASE+EXTMEM)  
0213 
0214 #define V2P(a) (((uint) (a)) - KERNBASE)
0215 #define P2V(a) (((void *) (a)) + KERNBASE)
0216 
0217 #define V2P_WO(x) ((x) - KERNBASE)    
0218 #define P2V_WO(x) ((x) + KERNBASE)    
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 
0376 
0377 void            swtch(struct context**, struct context*);
0378 
0379 
0380 void            acquire(struct spinlock*);
0381 void            getcallerpcs(void*, uint*);
0382 int             holding(struct spinlock*);
0383 void            initlock(struct spinlock*, char*);
0384 void            release(struct spinlock*);
0385 void            pushcli(void);
0386 void            popcli(void);
0387 
0388 
0389 void            acquiresleep(struct sleeplock*);
0390 void            releasesleep(struct sleeplock*);
0391 int             holdingsleep(struct sleeplock*);
0392 void            initsleeplock(struct sleeplock*, char*);
0393 
0394 
0395 int             memcmp(const void*, const void*, uint);
0396 void*           memmove(void*, const void*, uint);
0397 void*           memset(void*, int, uint);
0398 char*           safestrcpy(char*, const char*, int);
0399 int             strlen(const char*);
0400 int             strncmp(const char*, const char*, uint);
0401 char*           strncpy(char*, const char*, int);
0402 
0403 
0404 int             argint(int, int*);
0405 int             argptr(int, char**, int);
0406 int             argstr(int, char**);
0407 int             fetchint(uint, int*);
0408 int             fetchstr(uint, char**);
0409 void            syscall(void);
0410 
0411 
0412 void            timerinit(void);
0413 
0414 
0415 void            idtinit(void);
0416 extern uint     ticks;
0417 void            tvinit(void);
0418 extern struct spinlock tickslock;
0419 
0420 
0421 void            uartinit(void);
0422 void            uartintr(void);
0423 void            uartputc(int);
0424 
0425 
0426 void            seginit(void);
0427 void            kvmalloc(void);
0428 pde_t*          setupkvm(void);
0429 char*           uva2ka(pde_t*, char*);
0430 int             allocuvm(pde_t*, uint, uint);
0431 int             deallocuvm(pde_t*, uint, uint);
0432 void            freevm(pde_t*);
0433 void            inituvm(pde_t*, char*, uint);
0434 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0435 pde_t*          copyuvm(pde_t*, uint);
0436 void            switchuvm(struct proc*);
0437 void            switchkvm(void);
0438 int             copyout(pde_t*, uint, void*, uint);
0439 void            clearpteu(pde_t *pgdir, char *uva);
0440 
0441 
0442 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 
0453 
0454 #define SEG_NULLASM                                             \
0455         .word 0, 0;                                             \
0456         .byte 0, 0, 0, 0
0457 
0458 
0459 
0460 #define SEG_ASM(type,base,lim)                                  \
0461         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0462         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0463                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0464 
0465 #define STA_X     0x8       
0466 #define STA_E     0x4       
0467 #define STA_C     0x4       
0468 #define STA_W     0x2       
0469 #define STA_R     0x2       
0470 #define STA_A     0x1       
0471 
0472 
0473 
0474 
0475 
0476 
0477 
0478 
0479 
0480 
0481 
0482 
0483 
0484 
0485 
0486 
0487 
0488 
0489 
0490 
0491 
0492 
0493 
0494 
0495 
0496 
0497 
0498 
0499 
0500 
0501 
0502 
0503 /*
0504 
0505 #define FL_CF           0x00000001      
0506 #define FL_PF           0x00000004      
0507 #define FL_AF           0x00000010      
0508 #define FL_ZF           0x00000040      
0509 #define FL_SF           0x00000080      
0510 #define FL_TF           0x00000100      
0511 #define FL_IF           0x00000200      
0512 #define FL_DF           0x00000400      
0513 #define FL_OF           0x00000800      
0514 #define FL_IOPL_MASK    0x00003000      
0515 #define FL_IOPL_0       0x00000000      
0516 #define FL_IOPL_1       0x00001000      
0517 #define FL_IOPL_2       0x00002000      
0518 #define FL_IOPL_3       0x00003000      
0519 #define FL_NT           0x00004000      
0520 #define FL_RF           0x00010000      
0521 #define FL_VM           0x00020000      
0522 #define FL_AC           0x00040000      
0523 #define FL_VIF          0x00080000      
0524 #define FL_VIP          0x00100000      
0525 #define FL_ID           0x00200000      
0526 */
0527 
0528 
0529 #define S_MIE	0x00000008
0530 #define S_MPIE	0x00000080
0531 
0532 
0533 #define CR0_PE          0x00000001      
0534 #define CR0_MP          0x00000002      
0535 #define CR0_EM          0x00000004      
0536 #define CR0_TS          0x00000008      
0537 #define CR0_ET          0x00000010      
0538 #define CR0_NE          0x00000020      
0539 #define CR0_WP          0x00010000      
0540 #define CR0_AM          0x00040000      
0541 #define CR0_NW          0x20000000      
0542 #define CR0_CD          0x40000000      
0543 #define CR0_PG          0x80000000      
0544 
0545 #define CR4_PSE         0x00000010      
0546 
0547 
0548 
0549 
0550 
0551 #define SEG_KCODE 1  
0552 #define SEG_KDATA 2  
0553 #define SEG_UCODE 3  
0554 #define SEG_UDATA 4  
0555 #define SEG_TSS   5  
0556 
0557 
0558 #define NSEGS     6
0559 
0560 #ifndef __ASSEMBLER__
0561 
0562 struct segdesc {
0563   uint lim_15_0 : 16;  
0564   uint base_15_0 : 16; 
0565   uint base_23_16 : 8; 
0566   uint type : 4;       
0567   uint s : 1;          
0568   uint dpl : 2;        
0569   uint p : 1;          
0570   uint lim_19_16 : 4;  
0571   uint avl : 1;        
0572   uint rsv1 : 1;       
0573   uint db : 1;         
0574   uint g : 1;          
0575   uint base_31_24 : 8; 
0576 };
0577 
0578 
0579 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0580 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0581   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0582   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0583 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0584 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0585   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0586   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0587 #endif
0588 
0589 #define DPL_USER    0x3     
0590 
0591 
0592 #define STA_X       0x8     
0593 #define STA_E       0x4     
0594 #define STA_C       0x4     
0595 #define STA_W       0x2     
0596 #define STA_R       0x2     
0597 #define STA_A       0x1     
0598 
0599 
0600 
0601 #define STS_T16A    0x1     
0602 #define STS_LDT     0x2     
0603 #define STS_T16B    0x3     
0604 #define STS_CG16    0x4     
0605 #define STS_TG      0x5     
0606 #define STS_IG16    0x6     
0607 #define STS_TG16    0x7     
0608 #define STS_T32A    0x9     
0609 #define STS_T32B    0xB     
0610 #define STS_CG32    0xC     
0611 #define STS_IG32    0xE     
0612 #define STS_TG32    0xF     
0613 
0614 
0615 
0616 
0617 
0618 
0619 
0620 
0621 
0622 
0623 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0624 
0625 
0626 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0627 
0628 
0629 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0630 
0631 
0632 #define NPDENTRIES      1024    
0633 #define NPTENTRIES      1024    
0634 #define PGSIZE          4096    
0635 
0636 #define PGSHIFT         12      
0637 #define PTXSHIFT        12      
0638 #define PDXSHIFT        22      
0639 
0640 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0641 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 #define PTE_V           0x001   
0654 #define PTE_R           0x002   
0655 #define PTE_W           0x004   
0656 #define PTE_X         0x008   
0657 #define PTE_U         0x010   
0658 #define PTE_G           0x020   
0659 #define PTE_A           0x040   
0660 #define PTE_D          0x080   
0661 
0662 
0663 
0664 
0665 
0666 #define PTE_ADDR(pte)   ((uint)(pte) >> 10) * PGSIZE
0667 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFF)
0668 
0669 #ifndef __ASSEMBLER__
0670 typedef uint pte_t;
0671 
0672 
0673 struct taskstate {
0674   uint link;         
0675   uint esp0;         
0676   ushort ss0;        
0677   ushort padding1;
0678   uint *esp1;
0679   ushort ss1;
0680   ushort padding2;
0681   uint *esp2;
0682   ushort ss2;
0683   ushort padding3;
0684   void *cr3;         
0685   uint *eip;         
0686   uint eflags;
0687   uint eax;          
0688   uint ecx;
0689   uint edx;
0690   uint ebx;
0691   uint *esp;
0692   uint *ebp;
0693   uint esi;
0694   uint edi;
0695   ushort es;         
0696   ushort padding4;
0697   ushort cs;
0698   ushort padding5;
0699   ushort ss;
0700   ushort padding6;
0701   ushort ds;
0702   ushort padding7;
0703   ushort fs;
0704   ushort padding8;
0705   ushort gs;
0706   ushort padding9;
0707   ushort ldt;
0708   ushort padding10;
0709   ushort t;          
0710   ushort iomb;       
0711 };
0712 
0713 
0714 
0715 /*
0716 struct gatedesc {
0717   uint off_15_0 : 16;   
0718   uint cs : 16;         
0719   uint args : 5;        
0720   uint rsv1 : 3;        
0721   uint type : 4;        
0722   uint s : 1;           
0723   uint dpl : 2;         
0724   uint p : 1;           
0725   uint off_31_16 : 16;  
0726 };
0727 */
0728 
0729 
0730 
0731 
0732 
0733 
0734 
0735 
0736 
0737 /*
0738 #define SETGATE(gate, istrap, sel, off, d)                \
0739 {                                                         \
0740   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0741   (gate).cs = (sel);                                      \
0742   (gate).args = 0;                                        \
0743   (gate).rsv1 = 0;                                        \
0744   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0745   (gate).s = 0;                                           \
0746   (gate).dpl = (d);                                       \
0747   (gate).p = 1;                                           \
0748   (gate).off_31_16 = (uint)(off) >> 16;                  \
0749 }
0750 */
0751 #endif
0752 
0753 
0754 
0755 
0756 
0757 
0758 
0759 
0760 
0761 
0762 
0763 
0764 
0765 
0766 
0767 
0768 
0769 
0770 
0771 
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 
0783 
0784 
0785 
0786 
0787 
0788 
0789 
0790 
0791 
0792 
0793 
0794 
0795 
0796 
0797 
0798 
0799 
0800 
0801 
0802 #define ELF_MAGIC 0x464C457FU  
0803 
0804 
0805 struct elfhdr {
0806   uint magic;  
0807   uchar elf[12];
0808   ushort type;
0809   ushort machine;
0810   uint version;
0811   uint entry;
0812   uint phoff;
0813   uint shoff;
0814   uint flags;
0815   ushort ehsize;
0816   ushort phentsize;
0817   ushort phnum;
0818   ushort shentsize;
0819   ushort shnum;
0820   ushort shstrndx;
0821 };
0822 
0823 
0824 struct proghdr {
0825   uint type;
0826   uint off;
0827   uint vaddr;
0828   uint paddr;
0829   uint filesz;
0830   uint memsz;
0831   uint flags;
0832   uint align;
0833 };
0834 
0835 
0836 #define ELF_PROG_LOAD           1
0837 
0838 
0839 #define ELF_PROG_FLAG_EXEC      1
0840 #define ELF_PROG_FLAG_WRITE     2
0841 #define ELF_PROG_FLAG_READ      4
0842 
0843 
0844 
0845 
0846 
0847 
0848 
0849 
0850 
0851 
0852 
0853 
0854 
0855 
0856 .p2align 2
0857 .text
0858 .globl multiboot_header
0859 multiboot_header:
0860   
0861   
0862   .long magic
0863   .long flags
0864   .long (-magic-flags)
0865 
0866 
0867 
0868 
0869 .globl _start
0870 _start = V2P_WO(entry)
0871 
0872 
0873 .globl entry
0874 entry:
0875   
0876   
0877   
0878   
0879   
0880   
0881 
0882 
0883 	
0884 	li t1,0x80000
0885 
0886 
0887 
0888 	csrs mstatus,t1
0889 /*
0890   la	  t0,V2P_WO(entrypgdir)
0891   li 	  t4,0x80000000
0892   sub 	  t0,t0,t4
0893 */
0894   la	  t0,entrypgdir
0895   srli    t0,t0,12
0896   csrw    satp, t0
0897   
0898   csrr    t0,satp
0899   li	 t1,0x80000000
0900   or     t0,t0,t1
0901   csrw    satp, t0
0902 
0903   
0904   
0905   la	sp, (stack + KSTACKSIZE)
0906   li	t1,KERNBASE
0907   add  sp, sp,t1
0908 
0909   
0910   
0911   
0912   
0913   
0914   la t0, main
0915   li	 t1,KERNBASE
0916   add t0,t0,t1
0917   jr t0
0918 
0919 .comm stack, KSTACKSIZE
0920 
0921 
0922 
0923 
0924 
0925 
0926 
0927 
0928 
0929 
0930 
0931 
0932 
0933 
0934 
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 
0953 
0954 
0955 
0956 
0957 
0958 
0959 
0960 
0961 
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 .code16
0972 .globl start
0973 start:
0974   cli
0975 
0976   
0977   xorw    %ax,%ax
0978   movw    %ax,%ds
0979   movw    %ax,%es
0980   movw    %ax,%ss
0981 
0982   
0983   
0984   
0985   lgdt    gdtdesc
0986   movl    %cr0, %eax
0987   orl     $CR0_PE, %eax
0988   movl    %eax, %cr0
0989 
0990   
0991   
0992   
0993   ljmpl    $(SEG_KCODE<<3), $(start32)
0994 
0995 
0996 
0997 
0998 
0999 
1000 .code32  
1001 start32:
1002   
1003   movw    $(SEG_KDATA<<3), %ax    
1004   movw    %ax, %ds                
1005   movw    %ax, %es                
1006   movw    %ax, %ss                
1007   movw    $0, %ax                 
1008   movw    %ax, %fs                
1009   movw    %ax, %gs                
1010 
1011   
1012   movl    %cr4, %eax
1013   orl     $(CR4_PSE), %eax
1014   movl    %eax, %cr4
1015   
1016   movl    (start-12), %eax
1017   movl    %eax, %cr3
1018   
1019   movl    %cr0, %eax
1020   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1021   movl    %eax, %cr0
1022 
1023   
1024   movl    (start-4), %esp
1025   
1026   call	 *(start-8)
1027 
1028   movw    $0x8a00, %ax
1029   movw    %ax, %dx
1030   outw    %ax, %dx
1031   movw    $0x8ae0, %ax
1032   outw    %ax, %dx
1033 spin:
1034   jmp     spin
1035 
1036 .p2align 2
1037 gdt:
1038   SEG_NULLASM
1039   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1040   SEG_ASM(STA_W, 0, 0xffffffff)
1041 
1042 
1043 gdtdesc:
1044   .word   (gdtdesc - gdt - 1)
1045   .long   gdt
1046 
1047 
1048 
1049 
1050 #include "types.h"
1051 #include "defs.h"
1052 #include "param.h"
1053 #include "memlayout.h"
1054 #include "mmu.h"
1055 #include "proc.h"
1056 #include "riscv.h"
1057 
1058 
1059 static void mpmain(void)  __attribute__((noreturn));
1060 extern pde_t *kpgdir;
1061 extern char end[]; 
1062 
1063 
1064 
1065 
1066 int
1067 main(void)
1068 {
1069 
1070   kinit1(end, P2V(4*1024*1024)); 
1071 
1072   kvmalloc();      
1073 
1074   
1075 
1076   lapicinit();     
1077 
1078  
1079 
1080   
1081 
1082   
1083 
1084   consoleinit();   
1085 
1086   uartinit();      
1087 
1088 
1089   pinit();         
1090 
1091   tvinit();        
1092 
1093   binit();         
1094 
1095   fileinit();      
1096 
1097   ideinit();       
1098 
1099   
1100 
1101   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1102 
1103   userinit();      
1104 
1105   mpmain();        
1106 }
1107 
1108 
1109 
1110 /*
1111 static void
1112 mpenter(void)
1113 {
1114   switchkvm();
1115   seginit();
1116   lapicinit();
1117   mpmain();
1118 }
1119 */
1120 
1121 
1122 static void
1123 mpmain(void)
1124 {
1125   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1126   
1127   idtinit();       
1128   xchg(&(mycpu()->started), 1); 
1129   
1130   scheduler();     
1131 }
1132 
1133 pde_t entrypgdir[];  
1134 
1135 
1136 
1137 /*
1138 static void
1139 startothers(void)
1140 {
1141   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1142   uchar *code;
1143   struct cpu *c;
1144   char *stack;
1145 
1146   
1147   
1148   
1149   code = P2V(0x7000);
1150   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1151 
1152   for(c = cpus; c < cpus+ncpu; c++){
1153     if(c == mycpu())  
1154       continue;
1155 
1156     
1157     
1158     
1159     stack = kalloc();
1160     *(void**)(code-4) = stack + KSTACKSIZE;
1161     *(void**)(code-8) = mpenter;
1162     *(int**)(code-12) = (void *) V2P(entrypgdir);
1163 
1164     lapicstartap(c->apicid, V2P(code));
1165 
1166     
1167     while(c->started == 0)
1168       ;
1169   }
1170 }
1171 */
1172 
1173 
1174 
1175 
1176 
1177 
1178 __attribute__((__aligned__(PGSIZE)))
1179 pde_t entrypgdir[NPDENTRIES] = {
1180   
1181  
1182   [0] = (0) | PTE_V | PTE_R | PTE_X | PTE_W,
1183   
1184   
1185   [KERNBASE>>PDXSHIFT] = (0) | PTE_V | PTE_R | PTE_X | PTE_W,
1186 };
1187 
1188 
1189 
1190 
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 
1201 
1202 
1203 
1204 
1205 
1206 
1207 
1208 
1209 
1210 
1211 
1212 
1213 
1214 
1215 
1216 
1217 
1218 
1219 
1220 
1221 
1222 
1223 
1224 
1225 
1226 
1227 
1228 
1229 
1230 
1231 
1232 
1233 
1234 
1235 
1236 
1237 
1238 
1239 
1240 
1241 
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 
1252 
1253 
1254 
1255 
1256 
1257 
1258 
1259 
1260 
1261 
1262 
1263 
1264 
1265 
1266 
1267 
1268 
1269 
1270 
1271 
1272 
1273 
1274 
1275 
1276 
1277 
1278 
1279 
1280 
1281 
1282 
1283 
1284 
1285 
1286 
1287 
1288 
1289 
1290 
1291 
1292 
1293 
1294 
1295 
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 
1306 
1307 
1308 
1309 
1310 
1311 
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 struct spinlock {
1352   uint locked;       
1353 
1354   
1355   char *name;        
1356   struct cpu *cpu;   
1357   uint pcs[10];      
1358                      
1359 };
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 #include "types.h"
1403 #include "defs.h"
1404 #include "param.h"
1405 #include "memlayout.h"
1406 #include "mmu.h"
1407 #include "proc.h"
1408 #include "spinlock.h"
1409 #include "riscv.h"
1410 
1411 void
1412 initlock(struct spinlock *lk, char *name)
1413 {
1414   lk->name = name;
1415   lk->locked = 0;
1416   lk->cpu = 0;
1417 }
1418 
1419 
1420 
1421 
1422 
1423 void
1424 acquire(struct spinlock *lk)
1425 {
1426   pushcli(); 
1427   if(holding(lk))
1428     panic("acquire");
1429 
1430   
1431   while(xchg(&lk->locked, 1) != 0)
1432     ;
1433 
1434   
1435   
1436   
1437   
1438   
1439 
1440   
1441   lk->cpu = mycpu();
1442   getcallerpcs(&lk, lk->pcs);
1443 }
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 void
1452 release(struct spinlock *lk)
1453 {
1454   if(!holding(lk))
1455     panic("release");
1456 
1457   lk->pcs[0] = 0;
1458   lk->cpu = 0;
1459 
1460   
1461   
1462   
1463   
1464   
1465   
1466   
1467 
1468   
1469   
1470   
1471   asm volatile("sw zero, %0" : "+m" (lk->locked) : );
1472 
1473   popcli();
1474 }
1475 
1476 
1477 void
1478 getcallerpcs(void *v, uint pcs[])
1479 {
1480 	/*
1481   uint *ebp;
1482   int i;
1483 
1484   ebp = (uint*)v - 2;
1485   for(i = 0; i < 10; i++){
1486     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1487       break;
1488     pcs[i] = ebp[1];     
1489     ebp = (uint*)ebp[0]; 
1490   }
1491   for(; i < 10; i++)
1492     pcs[i] = 0;
1493 	*/
1494 }
1495 
1496 
1497 
1498 
1499 
1500 
1501 int
1502 holding(struct spinlock *lock)
1503 {
1504   return lock->locked && lock->cpu == mycpu();
1505 }
1506 
1507 
1508 
1509 
1510 
1511 
1512 void
1513 pushcli(void)
1514 {
1515   int eflags;
1516 
1517   
1518   eflags = read_status();
1519   cli();
1520   if(mycpu()->ncli == 0)
1521     mycpu()->intena = eflags & S_MIE;
1522   mycpu()->ncli += 1;
1523 }
1524 
1525 void
1526 popcli(void)
1527 {
1528   if(read_status()&S_MIE)
1529     panic("popcli - interruptible");
1530   if(--mycpu()->ncli < 0)
1531     panic("popcli");
1532   if(mycpu()->ncli == 0 && mycpu()->intena)
1533     sti();
1534 }
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 #include "param.h"
1551 #include "types.h"
1552 #include "defs.h"
1553 #include "riscv.h"
1554 #include "memlayout.h"
1555 #include "mmu.h"
1556 #include "proc.h"
1557 #include "elf.h"
1558 
1559 extern char data[];  
1560 pde_t *kpgdir;  
1561 
1562 
1563 
1564 /*
1565 void
1566 seginit(void)
1567 {
1568   struct cpu *c;
1569 
1570   
1571   
1572   
1573   
1574   c = &cpus[cpuid()];
1575   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1576   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1577   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1578   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1579   lgdt(c->gdt, sizeof(c->gdt));
1580 }
1581 */
1582 
1583 
1584 
1585 
1586 static pte_t *
1587 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1588 {
1589   pde_t *pde;
1590   pte_t *pgtab;
1591 
1592   pde = &pgdir[PDX(va)];
1593   if(*pde & PTE_V){
1594     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1595   } else {
1596     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1597       return 0;
1598     
1599     memset(pgtab, 0, PGSIZE);
1600     
1601     
1602     
1603     
1604     *pde = (V2P(pgtab) >> 2)  | PTE_V ;
1605     
1606   }
1607   return &pgtab[PTX(va)];
1608 }
1609 
1610 
1611 
1612 
1613 
1614 static int
1615 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1616 {
1617   char *a, *last;
1618   pte_t *pte;
1619 
1620   
1621   
1622   a = (char*)PGROUNDDOWN((uint)va);
1623   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1624   for(;;){
1625 	
1626 	if((pte = walkpgdir(pgdir, a, 1)) == 0)
1627 		  return -1;
1628     if(*pte & PTE_V)
1629       panic("remap");
1630     *pte = (pa >> 2) | perm | PTE_V;
1631     if(a == last){
1632       break;
1633 	}
1634     a += PGSIZE;
1635     pa += PGSIZE;
1636   }
1637   return 0;
1638 }
1639 
1640 
1641 
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 
1652 
1653 
1654 
1655 
1656 
1657 
1658 
1659 
1660 
1661 
1662 
1663 
1664 
1665 
1666 
1667 
1668 
1669 
1670 
1671 
1672 
1673 static struct kmap {
1674   void *virt;
1675   uint phys_start;
1676   uint phys_end;
1677   int perm;
1678 } kmap[] = {
1679  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W | PTE_R}, 
1680  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), PTE_X | PTE_R},     
1681  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W | PTE_R}, 
1682  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W | PTE_R}, 
1683 };
1684 
1685 
1686 pde_t*
1687 setupkvm(void)
1688 {
1689   pde_t *pgdir;
1690   struct kmap *k;
1691 
1692   
1693   if((pgdir = (pde_t*)kalloc()) == 0)
1694     return 0;
1695   memset(pgdir, 0, PGSIZE);
1696   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1697     panic("PHYSTOP too high");
1698   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1699 	
1700     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1701                 (uint)k->phys_start, k->perm) < 0) {
1702       freevm(pgdir);
1703       return 0;
1704     }
1705   return pgdir;
1706 }
1707 
1708 
1709 
1710 void
1711 kvmalloc(void)
1712 {
1713   
1714   kpgdir = setupkvm();
1715   
1716   switchkvm();
1717 }
1718 
1719 
1720 
1721 void
1722 switchkvm(void)
1723 {
1724   lcr3(V2P(kpgdir));   
1725 }
1726 
1727 
1728 void
1729 switchuvm(struct proc *p)
1730 {
1731   if(p == 0)
1732     panic("switchuvm: no process");
1733   if(p->kstack == 0)
1734     panic("switchuvm: no kstack");
1735   if(p->pgdir == 0)
1736     panic("switchuvm: no pgdir");
1737 
1738   pushcli();
1739   
1740   /*
1741   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1742                                 sizeof(mycpu()->ts)-1, 0);
1743   mycpu()->gdt[SEG_TSS].s = 0;
1744   mycpu()->ts.ss0 = SEG_KDATA << 3;
1745   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1746   
1747   
1748   mycpu()->ts.iomb = (ushort) 0xFFFF;
1749   ltr(SEG_TSS << 3);
1750   */
1751   
1752   write_scratch((uint)p->kstack + KSTACKSIZE);
1753   lcr3(V2P(p->pgdir));  
1754   popcli();
1755 }
1756 
1757 
1758 
1759 void
1760 inituvm(pde_t *pgdir, char *init, uint sz)
1761 {
1762   char *mem;
1763 
1764   if(sz >= PGSIZE)
1765     panic("inituvm: more than a page");
1766   mem = kalloc();
1767   memset(mem, 0, PGSIZE);
1768   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U|PTE_R|PTE_X);
1769   memmove(mem, init, sz);
1770 }
1771 
1772 
1773 
1774 int
1775 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1776 {
1777   uint i, pa, n;
1778   pte_t *pte;
1779 
1780   if((uint) addr % PGSIZE != 0)
1781     panic("loaduvm: addr must be page aligned");
1782   for(i = 0; i < sz; i += PGSIZE){
1783     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1784       panic("loaduvm: address should exist");
1785     pa = PTE_ADDR(*pte);
1786     if(sz - i < PGSIZE)
1787       n = sz - i;
1788     else
1789       n = PGSIZE;
1790     if(readi(ip, P2V(pa), offset+i, n) != n)
1791       return -1;
1792   }
1793   return 0;
1794 }
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 int
1803 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1804 {
1805   char *mem;
1806   uint a;
1807 
1808   if(newsz >= KERNBASE)
1809     return 0;
1810   if(newsz < oldsz)
1811     return oldsz;
1812 
1813   a = PGROUNDUP(oldsz);
1814   for(; a < newsz; a += PGSIZE){
1815     mem = kalloc();
1816     if(mem == 0){
1817       cprintf("allocuvm out of memory\n");
1818       deallocuvm(pgdir, newsz, oldsz);
1819       return 0;
1820     }
1821     memset(mem, 0, PGSIZE);
1822     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U|PTE_R|PTE_X) < 0){
1823       cprintf("allocuvm out of memory (2)\n");
1824       deallocuvm(pgdir, newsz, oldsz);
1825       kfree(mem);
1826       return 0;
1827     }
1828   }
1829   return newsz;
1830 }
1831 
1832 
1833 
1834 
1835 
1836 int
1837 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1838 {
1839   pte_t *pte;
1840   uint a, pa;
1841 
1842   if(newsz >= oldsz)
1843     return oldsz;
1844 
1845   a = PGROUNDUP(newsz);
1846   for(; a  < oldsz; a += PGSIZE){
1847     pte = walkpgdir(pgdir, (char*)a, 0);
1848     if(!pte)
1849       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
1850     else if((*pte & PTE_V) != 0){
1851       pa = PTE_ADDR(*pte);
1852       if(pa == 0)
1853         panic("kfree");
1854       char *v = P2V(pa);
1855       kfree(v);
1856       *pte = 0;
1857     }
1858   }
1859   return newsz;
1860 }
1861 
1862 
1863 
1864 void
1865 freevm(pde_t *pgdir)
1866 {
1867   uint i;
1868 
1869   if(pgdir == 0)
1870     panic("freevm: no pgdir");
1871   deallocuvm(pgdir, KERNBASE, 0);
1872   for(i = 0; i < NPDENTRIES; i++){
1873     if(pgdir[i] & PTE_V){
1874       char * v = P2V(PTE_ADDR(pgdir[i]));
1875       kfree(v);
1876     }
1877   }
1878   kfree((char*)pgdir);
1879 }
1880 
1881 
1882 
1883 void
1884 clearpteu(pde_t *pgdir, char *uva)
1885 {
1886   pte_t *pte;
1887 
1888   pte = walkpgdir(pgdir, uva, 0);
1889   if(pte == 0)
1890     panic("clearpteu");
1891   *pte &= ~PTE_U;
1892 }
1893 
1894 
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 pde_t*
1903 copyuvm(pde_t *pgdir, uint sz)
1904 {
1905   pde_t *d;
1906   pte_t *pte;
1907   uint pa, i, flags;
1908   char *mem;
1909 
1910   if((d = setupkvm()) == 0)
1911     return 0;
1912   for(i = 0; i < sz; i += PGSIZE){
1913     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1914       panic("copyuvm: pte should exist");
1915     if(!(*pte & PTE_V))
1916       panic("copyuvm: page not present");
1917     pa = PTE_ADDR(*pte);
1918     flags = PTE_FLAGS(*pte);
1919     if((mem = kalloc()) == 0)
1920       goto bad;
1921     memmove(mem, (char*)P2V(pa), PGSIZE);
1922     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
1923       goto bad;
1924   }
1925   return d;
1926 
1927 bad:
1928   freevm(d);
1929   return 0;
1930 }
1931 
1932 
1933 
1934 
1935 
1936 
1937 
1938 
1939 
1940 
1941 
1942 
1943 
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 char*
1952 uva2ka(pde_t *pgdir, char *uva)
1953 {
1954   pte_t *pte;
1955 
1956   pte = walkpgdir(pgdir, uva, 0);
1957   if((*pte & PTE_V) == 0)
1958     return 0;
1959   if((*pte & PTE_U) == 0)
1960     return 0;
1961   return (char*)P2V(PTE_ADDR(*pte));
1962 }
1963 
1964 
1965 
1966 
1967 int
1968 copyout(pde_t *pgdir, uint va, void *p, uint len)
1969 {
1970   char *buf, *pa0;
1971   uint n, va0;
1972 
1973   buf = (char*)p;
1974   while(len > 0){
1975     va0 = (uint)PGROUNDDOWN(va);
1976     pa0 = uva2ka(pgdir, (char*)va0);
1977     if(pa0 == 0)
1978       return -1;
1979     n = PGSIZE - (va - va0);
1980     if(n > len)
1981       n = len;
1982     memmove(pa0 + (va - va0), buf, n);
1983     len -= n;
1984     buf += n;
1985     va = va0 + PGSIZE;
1986   }
1987   return 0;
1988 }
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 
2002 
2003 
2004 
2005 
2006 
2007 
2008 
2009 
2010 
2011 
2012 
2013 
2014 
2015 
2016 
2017 
2018 
2019 
2020 
2021 
2022 
2023 
2024 
2025 
2026 
2027 
2028 
2029 
2030 
2031 
2032 
2033 
2034 
2035 
2036 
2037 
2038 
2039 
2040 
2041 
2042 
2043 
2044 
2045 
2046 
2047 
2048 
2049 
2050 
2051 
2052 
2053 
2054 
2055 
2056 
2057 
2058 
2059 
2060 
2061 
2062 
2063 
2064 
2065 
2066 
2067 
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 
2102 
2103 
2104 
2105 
2106 
2107 
2108 
2109 
2110 
2111 
2112 
2113 
2114 
2115 
2116 
2117 
2118 
2119 
2120 
2121 
2122 
2123 
2124 
2125 
2126 
2127 
2128 
2129 
2130 
2131 
2132 
2133 
2134 
2135 
2136 
2137 
2138 
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 struct cpu {
2152   uchar apicid;                
2153   struct context *scheduler;   
2154   
2155   
2156   volatile uint started;       
2157   int ncli;                    
2158   int intena;                  
2159   struct proc *proc;           
2160 };
2161 
2162 extern struct cpu cpus[NCPU];
2163 extern int ncpu;
2164 
2165 
2166 
2167 
2168 
2169 
2170 
2171 
2172 
2173 
2174 
2175 
2176 struct context {
2177   
2178   
2179   
2180   
2181   
2182   uint s0;
2183   uint s1;
2184   uint s2;
2185   uint s3;
2186   uint s4;
2187   uint s5;
2188   uint s6;
2189   uint s7;
2190   uint s8;
2191   uint s9;
2192   uint s10;
2193   uint s11;
2194   uint ra;
2195 };
2196 
2197 
2198 
2199 
2200 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2201 
2202 
2203 struct proc {
2204   uint sz;                     
2205   pde_t* pgdir;                
2206   char *kstack;                
2207   enum procstate state;        
2208   int pid;                     
2209   struct proc *parent;         
2210   struct trapframe *tf;        
2211   struct context *context;     
2212   void *chan;                  
2213   int killed;                  
2214   struct file *ofile[NOFILE];  
2215   struct inode *cwd;           
2216   char name[16];               
2217 };
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 #include "types.h"
2251 #include "defs.h"
2252 #include "param.h"
2253 #include "memlayout.h"
2254 #include "mmu.h"
2255 #include "proc.h"
2256 #include "spinlock.h"
2257 #include "riscv.h"
2258 
2259 struct {
2260   struct spinlock lock;
2261   struct proc proc[NPROC];
2262 } ptable;
2263 
2264 static struct proc *initproc;
2265 
2266 int nextpid = 1;
2267 extern void forkret(void);
2268 extern void trapret(void);
2269 
2270 static void wakeup1(void *chan);
2271 
2272 void
2273 pinit(void)
2274 {
2275   initlock(&ptable.lock, "ptable");
2276 }
2277 
2278 
2279 int
2280 cpuid() {
2281   return mycpu()-cpus;
2282 }
2283 
2284 
2285 
2286 struct cpu*
2287 mycpu(void)
2288 {
2289   int apicid, i;
2290 
2291   if(read_status()&S_MIE)
2292     panic("mycpu called with interrupts enabled\n");
2293 
2294   apicid = lapicid();
2295   
2296   
2297   
2298   for (i = 0; i < 1; ++i) {
2299     if (cpus[i].apicid == apicid)
2300       return &cpus[i];
2301   }
2302   panic("unknown apicid\n");
2303 }
2304 
2305 
2306 
2307 struct proc*
2308 myproc(void) {
2309   struct cpu *c;
2310   struct proc *p;
2311   pushcli();
2312   c = mycpu();
2313   p = c->proc;
2314   popcli();
2315   return p;
2316 }
2317 
2318 
2319 
2320 
2321 
2322 
2323 
2324 
2325 
2326 
2327 
2328 
2329 
2330 
2331 
2332 
2333 
2334 
2335 
2336 
2337 
2338 
2339 
2340 
2341 
2342 
2343 
2344 
2345 
2346 
2347 
2348 
2349 
2350 
2351 
2352 
2353 
2354 static struct proc*
2355 allocproc(void)
2356 {
2357   struct proc *p;
2358   char *sp;
2359 
2360   acquire(&ptable.lock);
2361 
2362   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2363     if(p->state == UNUSED)
2364       goto found;
2365 
2366   release(&ptable.lock);
2367   return 0;
2368 
2369 found:
2370   p->state = EMBRYO;
2371   p->pid = nextpid++;
2372 
2373   release(&ptable.lock);
2374 
2375   
2376   if((p->kstack = kalloc()) == 0){
2377     p->state = UNUSED;
2378     return 0;
2379   }
2380   sp = p->kstack + KSTACKSIZE;
2381 
2382   
2383   sp -= sizeof *p->tf;
2384   p->tf = (struct trapframe*)sp;
2385 
2386   
2387   
2388   sp -= 4;
2389   *(uint*)sp = (uint)trapret;
2390 
2391   sp -= sizeof *p->context;
2392   p->context = (struct context*)sp;
2393   memset(p->context, 0, sizeof *p->context);
2394   p->context->ra = (uint)forkret;
2395 
2396   return p;
2397 }
2398 
2399 
2400 
2401 void
2402 userinit(void)
2403 {
2404   struct proc *p;
2405   extern char _binary_initcode_start[], _binary_initcode_size[];
2406 
2407   p = allocproc();
2408 
2409   initproc = p;
2410   if((p->pgdir = setupkvm()) == 0)
2411     panic("userinit: out of memory?");
2412   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2413   p->sz = PGSIZE;
2414   memset(p->tf, 0, sizeof(*p->tf));
2415 
2416   
2417   
2418   
2419   
2420   p->tf->mstatus = read_status() | S_MIE;
2421   p->tf->sp = PGSIZE;
2422   p->tf->mepc = 0;  
2423 
2424   safestrcpy(p->name, "initcode", sizeof(p->name));
2425   p->cwd = namei("/");
2426 
2427   
2428   
2429   
2430   
2431   acquire(&ptable.lock);
2432 
2433   p->state = RUNNABLE;
2434 
2435   release(&ptable.lock);
2436 }
2437 
2438 
2439 
2440 
2441 
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 int
2453 growproc(int n)
2454 {
2455   uint sz;
2456   struct proc *curproc = myproc();
2457 
2458   sz = curproc->sz;
2459   if(n > 0){
2460     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2461       return -1;
2462   } else if(n < 0){
2463     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2464       return -1;
2465   }
2466   curproc->sz = sz;
2467   switchuvm(curproc);
2468   return 0;
2469 }
2470 
2471 
2472 
2473 
2474 int
2475 fork(void)
2476 {
2477   int i, pid;
2478   struct proc *np;
2479   struct proc *curproc = myproc();
2480 
2481   
2482   if((np = allocproc()) == 0){
2483     return -1;
2484   }
2485 
2486   
2487   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2488     kfree(np->kstack);
2489     np->kstack = 0;
2490     np->state = UNUSED;
2491     return -1;
2492   }
2493   np->sz = curproc->sz;
2494   np->parent = curproc;
2495   *np->tf = *curproc->tf;
2496 
2497   
2498   np->tf->a0 = 0;
2499 
2500   for(i = 0; i < NOFILE; i++)
2501     if(curproc->ofile[i])
2502       np->ofile[i] = filedup(curproc->ofile[i]);
2503   np->cwd = idup(curproc->cwd);
2504 
2505   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2506 
2507   pid = np->pid;
2508 
2509   acquire(&ptable.lock);
2510 
2511   np->state = RUNNABLE;
2512 
2513   release(&ptable.lock);
2514 
2515   return pid;
2516 }
2517 
2518 
2519 
2520 
2521 void
2522 exit(void)
2523 {
2524   struct proc *curproc = myproc();
2525   struct proc *p;
2526   int fd;
2527 
2528   if(curproc == initproc)
2529     panic("init exiting");
2530 
2531   
2532   for(fd = 0; fd < NOFILE; fd++){
2533     if(curproc->ofile[fd]){
2534       fileclose(curproc->ofile[fd]);
2535       curproc->ofile[fd] = 0;
2536     }
2537   }
2538 
2539   begin_op();
2540   iput(curproc->cwd);
2541   end_op();
2542   curproc->cwd = 0;
2543 
2544   acquire(&ptable.lock);
2545 
2546   
2547   wakeup1(curproc->parent);
2548 
2549 
2550   
2551   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2552     if(p->parent == curproc){
2553       p->parent = initproc;
2554       if(p->state == ZOMBIE)
2555         wakeup1(initproc);
2556     }
2557   }
2558 
2559   
2560   curproc->state = ZOMBIE;
2561   sched();
2562   panic("zombie exit");
2563 }
2564 
2565 
2566 
2567 int
2568 wait(void)
2569 {
2570   struct proc *p;
2571   int havekids, pid;
2572   struct proc *curproc = myproc();
2573 
2574   acquire(&ptable.lock);
2575   for(;;){
2576     
2577     havekids = 0;
2578     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2579       if(p->parent != curproc)
2580         continue;
2581       havekids = 1;
2582       if(p->state == ZOMBIE){
2583         
2584         pid = p->pid;
2585         kfree(p->kstack);
2586         p->kstack = 0;
2587         freevm(p->pgdir);
2588         p->pid = 0;
2589         p->parent = 0;
2590         p->name[0] = 0;
2591         p->killed = 0;
2592         p->state = UNUSED;
2593         release(&ptable.lock);
2594         return pid;
2595       }
2596     }
2597 
2598 
2599 
2600     
2601     if(!havekids || curproc->killed){
2602       release(&ptable.lock);
2603       return -1;
2604     }
2605 
2606     
2607     sleep(curproc, &ptable.lock);  
2608   }
2609 }
2610 
2611 
2612 
2613 
2614 
2615 
2616 
2617 
2618 
2619 
2620 
2621 
2622 
2623 
2624 
2625 
2626 
2627 
2628 
2629 
2630 
2631 
2632 
2633 
2634 
2635 
2636 
2637 
2638 
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 
2655 
2656 
2657 void
2658 scheduler(void)
2659 {
2660   struct proc *p;
2661   struct cpu *c = mycpu();
2662   c->proc = 0;
2663 
2664   for(;;){
2665     
2666     sti();
2667 
2668     
2669     acquire(&ptable.lock);
2670     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2671       if(p->state != RUNNABLE)
2672         continue;
2673 
2674       
2675       
2676       
2677       c->proc = p;
2678 	  
2679       switchuvm(p);
2680       p->state = RUNNING;
2681 
2682       swtch(&(c->scheduler), p->context);
2683       switchkvm();
2684 
2685       
2686       
2687       c->proc = 0;
2688     }
2689     release(&ptable.lock);
2690 
2691   }
2692 }
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 
2701 
2702 
2703 
2704 
2705 
2706 
2707 void
2708 sched(void)
2709 {
2710   int intena;
2711   struct proc *p = myproc();
2712 
2713   if(!holding(&ptable.lock))
2714     panic("sched ptable.lock");
2715   if(mycpu()->ncli != 1)
2716     panic("sched locks");
2717   if(p->state == RUNNING)
2718     panic("sched running");
2719   if(read_status()&S_MIE)
2720     panic("sched interruptible");
2721   intena = mycpu()->intena;
2722   swtch(&p->context, mycpu()->scheduler);
2723   mycpu()->intena = intena;
2724 }
2725 
2726 
2727 void
2728 yield(void)
2729 {
2730   acquire(&ptable.lock);  
2731   myproc()->state = RUNNABLE;
2732   sched();
2733   release(&ptable.lock);
2734 }
2735 
2736 
2737 
2738 
2739 
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 void
2753 forkret(void)
2754 {
2755   static int first = 1;
2756   
2757   release(&ptable.lock);
2758 
2759   if (first) {
2760     
2761     
2762     
2763     first = 0;
2764     iinit(ROOTDEV);
2765     initlog(ROOTDEV);
2766   }
2767 
2768   
2769 }
2770 
2771 
2772 
2773 void
2774 sleep(void *chan, struct spinlock *lk)
2775 {
2776   struct proc *p = myproc();
2777 
2778   if(p == 0)
2779     panic("sleep");
2780 
2781   if(lk == 0)
2782     panic("sleep without lk");
2783 
2784   
2785   
2786   
2787   
2788   
2789   
2790   if(lk != &ptable.lock){  
2791     acquire(&ptable.lock);  
2792     release(lk);
2793   }
2794   
2795   p->chan = chan;
2796   p->state = SLEEPING;
2797 
2798   sched();
2799 
2800   
2801   p->chan = 0;
2802 
2803   
2804   if(lk != &ptable.lock){  
2805     release(&ptable.lock);
2806     acquire(lk);
2807   }
2808 }
2809 
2810 
2811 
2812 
2813 
2814 
2815 
2816 
2817 
2818 
2819 
2820 
2821 
2822 
2823 
2824 
2825 
2826 
2827 
2828 
2829 
2830 
2831 
2832 
2833 
2834 
2835 
2836 
2837 
2838 
2839 
2840 
2841 
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 static void
2853 wakeup1(void *chan)
2854 {
2855   struct proc *p;
2856 
2857   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2858     if(p->state == SLEEPING && p->chan == chan)
2859       p->state = RUNNABLE;
2860 }
2861 
2862 
2863 void
2864 wakeup(void *chan)
2865 {
2866   acquire(&ptable.lock);
2867   wakeup1(chan);
2868   release(&ptable.lock);
2869 }
2870 
2871 
2872 
2873 
2874 int
2875 kill(int pid)
2876 {
2877   struct proc *p;
2878 
2879   acquire(&ptable.lock);
2880   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2881     if(p->pid == pid){
2882       p->killed = 1;
2883       
2884       if(p->state == SLEEPING)
2885         p->state = RUNNABLE;
2886       release(&ptable.lock);
2887       return 0;
2888     }
2889   }
2890   release(&ptable.lock);
2891   return -1;
2892 }
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 
2903 void
2904 procdump(void)
2905 {
2906   static char *states[] = {
2907   [UNUSED]    "unused",
2908   [EMBRYO]    "embryo",
2909   [SLEEPING]  "sleep ",
2910   [RUNNABLE]  "runble",
2911   [RUNNING]   "run   ",
2912   [ZOMBIE]    "zombie"
2913   };
2914   int i;
2915   struct proc *p;
2916   char *state;
2917   uint pc[10];
2918 
2919   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2920     if(p->state == UNUSED)
2921       continue;
2922     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2923       state = states[p->state];
2924     else
2925       state = "???";
2926     cprintf("%d %s %s", p->pid, state, p->name);
2927     if(p->state == SLEEPING){
2928       getcallerpcs((uint*)p->context->ra, pc);
2929       for(i=0; i<10 && pc[i] != 0; i++)
2930         cprintf(" %p", pc[i]);
2931     }
2932     cprintf("\n");
2933   }
2934 }
2935 
2936 
2937 
2938 
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 
2953 
2954 
2955 
2956 
2957 
2958 .globl swtch
2959 swtch:
2960  
2961  
2962 
2963  
2964  
2965  
2966  
2967  
2968 
2969  
2970  
2971  
2972 
2973  
2974  
2975  
2976  
2977  
2978  
2979 
2980   addi sp, sp, -56
2981 
2982   
2983  
2984   sw a0, 52(sp)
2985   sw ra, 48(sp)
2986   sw s11, 44(sp)
2987   sw s10, 40(sp)
2988   sw s9, 36(sp)
2989   sw s8, 32(sp)
2990   sw s7, 28(sp)
2991   sw s6, 24(sp)
2992   sw s5, 20(sp)
2993   sw s4, 16(sp)
2994   sw s3, 12(sp)
2995   sw s2, 8(sp)
2996   sw s1, 4(sp)
2997   sw s0, 0(sp)
2998 
2999 
3000   
3001   sw sp, 0(a0)
3002   mv sp, a1
3003 
3004   
3005   lw ra, 52(sp)
3006   lw t0, 48(sp)
3007   lw s11, 44(sp)
3008   lw s10, 40(sp)
3009   lw s9, 36(sp)
3010   lw s8, 32(sp)
3011   lw s7, 28(sp)
3012   lw s6, 24(sp)
3013   lw s5, 20(sp)
3014   lw s4, 16(sp)
3015   lw s3, 12(sp)
3016   lw s2, 8(sp)
3017   lw s1, 4(sp)
3018   lw s0, 0(sp)
3019   addi sp, sp, 56
3020   jr t0
3021   nop
3022 /*
3023   lw ra, 52(sp)
3024   lw t0, 48(sp)
3025   lw s11, 44(sp)
3026   lw s10, 40(sp)
3027   lw s9, 36(sp)
3028   lw s8, 32(sp)
3029   lw s7, 28(sp)
3030   lw s6, 24(sp)
3031   lw s5, 20(sp)
3032   lw s4, 16(sp)
3033   lw s3, 12(sp)
3034   lw s2, 8(sp)
3035   lw s1, 4(sp)
3036   lw s0, 0(sp)
3037   addi sp, sp, 56
3038   jr t0
3039   nop
3040 */
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053 
3054 #include "types.h"
3055 #include "defs.h"
3056 #include "param.h"
3057 #include "memlayout.h"
3058 #include "mmu.h"
3059 #include "spinlock.h"
3060 
3061 void freerange(void *vstart, void *vend);
3062 extern char end[]; 
3063                    
3064 
3065 struct run {
3066   struct run *next;
3067 };
3068 
3069 struct {
3070   struct spinlock lock;
3071   int use_lock;
3072   struct run *freelist;
3073 } kmem;
3074 
3075 
3076 
3077 
3078 
3079 
3080 void
3081 kinit1(void *vstart, void *vend)
3082 {
3083   initlock(&kmem.lock, "kmem");
3084   kmem.use_lock = 0;
3085   
3086   freerange(vstart, vend);
3087 }
3088 
3089 void
3090 kinit2(void *vstart, void *vend)
3091 {
3092   freerange(vstart, vend);
3093   kmem.use_lock = 1;
3094 }
3095 
3096 
3097 
3098 
3099 
3100 void
3101 freerange(void *vstart, void *vend)
3102 {
3103   char *p;
3104   p = (char*)PGROUNDUP((uint)vstart);
3105   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3106     kfree(p);
3107 }
3108 
3109 
3110 
3111 
3112 
3113 void
3114 kfree(char *v)
3115 {
3116   struct run *r;
3117 
3118   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3119     panic("kfree");
3120 
3121   
3122   memset(v, 1, PGSIZE);
3123 
3124   if(kmem.use_lock)
3125     acquire(&kmem.lock);
3126   r = (struct run*)v;
3127   r->next = kmem.freelist;
3128   kmem.freelist = r;
3129   if(kmem.use_lock)
3130     release(&kmem.lock);
3131 }
3132 
3133 
3134 
3135 
3136 char*
3137 kalloc(void)
3138 {
3139   struct run *r;
3140 
3141   if(kmem.use_lock)
3142     acquire(&kmem.lock);
3143   r = kmem.freelist;
3144   if(r)
3145     kmem.freelist = r->next;
3146 
3147   if(kmem.use_lock)
3148     release(&kmem.lock);
3149 
3150   return (char*)r;
3151 }
3152 
3153 
3154 
3155 
3156 
3157 
3158 
3159 
3160 
3161 
3162 
3163 
3164 
3165 
3166 
3167 
3168 
3169 
3170 
3171 
3172 
3173 
3174 
3175 
3176 
3177 
3178 
3179 
3180 
3181 
3182 
3183 
3184 
3185 
3186 
3187 
3188 
3189 
3190 
3191 
3192 
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 
3201 
3202 
3203 #define T_DIVIDE         0      
3204 #define T_DEBUG          1      
3205 #define T_NMI            2      
3206 #define T_BRKPT          3      
3207 #define T_OFLOW          4      
3208 #define T_BOUND          5      
3209 #define T_ILLOP          6      
3210 #define T_DEVICE         7      
3211 #define T_DBLFLT         8      
3212 
3213 #define T_TSS           10      
3214 #define T_SEGNP         11      
3215 #define T_STACK         12      
3216 #define T_GPFLT         13      
3217 #define T_PGFLT         14      
3218 
3219 #define T_FPERR         16      
3220 #define T_ALIGN         17      
3221 #define T_MCHK          18      
3222 #define T_SIMDERR       19      
3223 
3224 
3225 
3226 #define T_SYSCALL       64      
3227 #define T_DEFAULT      500      
3228 
3229 #define T_IRQ0          32      
3230 
3231 #define IRQ_TIMER        0
3232 #define IRQ_KBD          1
3233 #define IRQ_COM1         4
3234 #define IRQ_IDE         14
3235 #define IRQ_ERROR       19
3236 #define IRQ_SPURIOUS    31
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #!/usr/bin/perl -w
3251 
3252 # Generate vectors.S, the trap/interrupt entry points.
3253 # There has to be one entry point per interrupt number
3254 # since otherwise there's no way for trap() to discover
3255 # the interrupt number.
3256 
3257 print "# generated by vectors.pl - do not edit\n";
3258 print "# handlers\n";
3259 print ".globl alltraps\n";
3260 for(my $i = 0; $i < 256; $i++){
3261     print ".globl vector$i\n";
3262     print "vector$i:\n";
3263     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3264 		print "  addi sp,sp,-4\n";
3265 		#print "  pushl \$0\n";
3266         print "  sw zero,0(sp)\n";
3267     }
3268 	print "  addi sp,sp,-4\n";
3269 	# print "  pushl \$$i\n";
3270 	print "  li t6,$i\n";
3271 	print "  sw t6,0(sp)\n";
3272 	#print "  jmp alltraps\n";
3273     print "  j alltraps\n";
3274 }
3275 
3276 print "\n# vector table\n";
3277 print ".data\n";
3278 print ".globl vectors\n";
3279 print "vectors:\n";
3280 for(my $i = 0; $i < 256; $i++){
3281     print "  .long vector$i\n";
3282 }
3283 
3284 # sample output:
3285 #   # handlers
3286 #   .globl alltraps
3287 #   .globl vector0
3288 #   vector0:
3289 #     pushl $0
3290 #     pushl $0
3291 #     jmp alltraps
3292 #   ...
3293 #
3294 #   # vector table
3295 #   .data
3296 #   .globl vectors
3297 #   vectors:
3298 #     .long vector0
3299 #     .long vector1
3300 #     .long vector2
3301 #   ...
3302 
3303 
3304 
3305 
3306 
3307 
3308 
3309 
3310 
3311 
3312 
3313 
3314 
3315 
3316 
3317 
3318 
3319 
3320 
3321 
3322 
3323 
3324 
3325 
3326 
3327 
3328 
3329 
3330 
3331 
3332 
3333 
3334 
3335 
3336 
3337 
3338 
3339 
3340 
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 
3351 
3352   
3353 
3354 
3355 /*
3356   
3357   pushl %ds
3358   pushl %es
3359   pushl %fs
3360   pushl %gs
3361   pushal
3362 
3363   
3364   movw $(SEG_KDATA<<3), %ax
3365   movw %ax, %ds
3366   movw %ax, %es
3367 
3368   
3369   pushl %esp
3370   call trap
3371   addl $4, %esp
3372 
3373   
3374 .globl trapret
3375 trapret:
3376   popal
3377   popl %gs
3378   popl %fs
3379   popl %es
3380   popl %ds
3381   addl $0x8, %esp  
3382   iret
3383 */
3384 
3385 .globl alltraps
3386 alltraps:
3387 
3388 	sw t6,-4(sp)
3389 	sw t5,-8(sp)
3390 	sw t4,-12(sp)
3391 	mv t6,sp
3392 	csrr t5,mcause
3393 	
3394 	li t4,0x80000003
3395 	beq t5,t4,trapmain
3396 	li t4,0x80000007
3397 	beq t5,t4,trapmain
3398 	li t4,0x8000000b
3399 	beq t5,t4,trapmain
3400 	csrr sp,mscratch
3401 
3402 trapmain:
3403 	addi sp,sp,-136
3404 
3405 	sw ra,0(sp)
3406 	sw gp,4(sp)
3407 	sw tp,8(sp)
3408 	sw t0,12(sp)
3409 	sw t1,16(sp)
3410 	sw t2,20(sp)
3411 	sw s0,24(sp)
3412 	sw s1,28(sp)
3413 	sw a0,32(sp)
3414 	sw a1,36(sp)
3415 	sw a2,40(sp)
3416 	sw a3,44(sp)
3417 	sw a4,48(sp)
3418 	sw a5,52(sp)
3419 	sw a6,56(sp)
3420 	sw a7,60(sp)
3421 	sw s2,64(sp)
3422 	sw s3,68(sp)
3423 	sw s4,72(sp)
3424 	sw s5,76(sp)
3425 	sw s6,80(sp)
3426 	sw s7,84(sp)
3427 	sw s8,88(sp)
3428 	sw s9,92(sp)
3429 	sw s10,96(sp)
3430 	sw s11,100(sp)
3431 	sw t3,104(sp)
3432 
3433 	
3434 	mv t3,t6
3435 	lw t4,-12(t3)
3436 	lw t5,-8(t3)
3437 	lw t6,-4(t3)
3438 	sw t4,108(sp)
3439 	sw t5,112(sp)
3440 	sw t6,116(sp)
3441 
3442 	csrr t0,mepc
3443 	csrr t1,mcause
3444 	csrr t2,mstatus
3445 	sw t0,120(sp)
3446 	sw t1,124(sp)
3447 	sw t2,128(sp)
3448 
3449 
3450 	sw t3,132(sp)
3451 	mv a0,sp
3452 	jal trap
3453 
3454 	
3455 
3456 
3457 .globl trapret
3458 trapret:
3459 	
3460 
3461 	lw ra,0(sp)
3462 	lw gp,4(sp)
3463 	lw tp,8(sp)
3464 	lw t0,12(sp)
3465 	lw t1,16(sp)
3466 	lw t2,20(sp)
3467 	lw s0,24(sp)
3468 	lw s1,28(sp)
3469 	lw a0,32(sp)
3470 	lw a1,36(sp)
3471 	lw a2,40(sp)
3472 	lw a3,44(sp)
3473 	lw a4,48(sp)
3474 	lw a5,52(sp)
3475 	lw a6,56(sp)
3476 	lw a7,60(sp)
3477 	lw s2,64(sp)
3478 	lw s3,68(sp)
3479 	lw s4,72(sp)
3480 	lw s5,76(sp)
3481 	lw s6,80(sp)
3482 	lw s7,84(sp)
3483 	lw s8,88(sp)
3484 	lw s9,92(sp)
3485 	lw s10,96(sp)
3486 	lw s11,100(sp)
3487 
3488 	lw t3,120(sp)
3489 	lw t4,124(sp)
3490 	lw t5,128(sp)
3491 	csrw mepc,t3
3492 	csrw mcause,t4
3493 	csrw mstatus,t5
3494 
3495 	lw t3,104(sp)
3496 	lw t4,108(sp)
3497 	lw t5,112(sp)
3498 	lw t6,116(sp)
3499 
3500 	addi sp,sp,132
3501 	
3502 	lw sp,0(sp)
3503 	mret
3504 
3505 
3506 
3507 
3508 
3509 
3510 
3511 
3512 
3513 
3514 
3515 
3516 
3517 
3518 
3519 
3520 
3521 
3522 
3523 
3524 
3525 
3526 
3527 
3528 
3529 
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 #include "types.h"
3551 #include "defs.h"
3552 #include "param.h"
3553 #include "memlayout.h"
3554 #include "mmu.h"
3555 #include "proc.h"
3556 #include "riscv.h"
3557 #include "traps.h"
3558 #include "spinlock.h"
3559 
3560 
3561 int idt[256];
3562 extern uint vectors[];  
3563 extern void* alltraps();
3564 struct spinlock tickslock;
3565 uint ticks;
3566 
3567 void
3568 tvinit(void)
3569 {
3570 /*
3571   int i;
3572 
3573   for(i = 0; i < 256; i++)
3574 
3575 	
3576     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3577   
3578   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3579 */
3580 
3581   initlock(&tickslock, "time");
3582   
3583   
3584   
3585   idt[0] = (int)alltraps;
3586   initlock(&tickslock, "time");
3587 }
3588 
3589 void
3590 idtinit(void)
3591 {
3592   
3593   ltvec(idt);
3594 }
3595 
3596 
3597 
3598 
3599 
3600 void
3601 trap(struct trapframe *tf)
3602 {
3603 	uint trapno = read_cause() & 0x7fffffff;
3604 	uint interrupt = read_cause() & ~0x7fffffff;
3605 
3606 	if(!interrupt){
3607 		if(trapno == 8 || trapno == 11){
3608 			if(myproc()->killed)
3609 				exit();
3610 			myproc()->tf = tf;
3611 			syscall();
3612 			if(myproc()->killed)
3613 				exit();
3614 			return;
3615 		}
3616 
3617 	}else{
3618 		switch(trapno){
3619 			
3620 			case 4:
3621 			case 7:
3622 				if(cpuid() == 0){
3623 					acquire(&tickslock);
3624 					ticks++;
3625 					wakeup(&ticks);
3626 					release(&tickslock);
3627 				}
3628 				
3629 				eoi(TIMER);
3630 				break;
3631 				/*
3632 				   case T_IRQ0 + IRQ_IDE:
3633 				   ideintr();
3634 				   lapiceoi();
3635 				   break;
3636 				   case T_IRQ0 + IRQ_IDE+1:
3637 				
3638 				break;
3639 				case T_IRQ0 + IRQ_KBD:
3640 				kbdintr();
3641 				lapiceoi();
3642 				break;
3643 				*/
3644 				
3645 			case 8:
3646 			case 11:
3647 				uartintr();
3648 				
3649 				eoi(EXTERNAL);
3650 				break;
3651 				/*
3652 				   case T_IRQ0 + 7:
3653 				   case T_IRQ0 + IRQ_SPURIOUS:
3654 				
3655 				
3656 				cprintf("cpu%d: spurious interrupt at %x\n",
3657 				cpuid(), tf->ra);
3658 				lapiceoi();
3659 				break;
3660 				*/
3661 
3662 			default:
3663 				/*
3664 				   if(myproc() == 0 || (tf->cs&3) == 0){
3665 				
3666 				cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3667 				tf->trapno, cpuid(), tf->eip, rcr2());
3668 				cprintf("unexpected trap %d from cpu %d eip %x\n",
3669 				tf->trapno, cpuid(), tf->ra);
3670 				panic("trap");
3671 				}
3672 				
3673 				cprintf("pid %d %s: trap %d err %d on cpu %d "
3674 				"eip 0x%x addr 0x%x--kill proc\n",
3675 				myproc()->pid, myproc()->name, tf->trapno,
3676 				tf->err, cpuid(), tf->eip, rcr2());
3677 				*/
3678 				cprintf("pid %d %s: trap %d on cpu %d "
3679 						"eip 0x%x addr --kill proc\n",
3680 						myproc()->pid, myproc()->name, trapno,
3681 						cpuid(), tf->ra);
3682 				myproc()->killed = 1;
3683 		}
3684 
3685 	}
3686 
3687 	
3688 	
3689 	
3690 	
3691 	if(myproc() && myproc()->killed)
3692 		exit();
3693 
3694 	
3695 	
3696 	if(myproc() && myproc()->state == RUNNING &&
3697 			(trapno == 4 || trapno == 7))
3698 		yield();
3699 
3700 	
3701 	
3702 	if(myproc() && myproc()->killed )
3703 		exit();
3704 }
3705 
3706 
3707 
3708 
3709 
3710 
3711 
3712 
3713 
3714 
3715 
3716 
3717 
3718 
3719 
3720 
3721 
3722 
3723 
3724 
3725 
3726 
3727 
3728 
3729 
3730 
3731 
3732 
3733 
3734 
3735 
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 
3751 #define SYS_fork    1
3752 #define SYS_exit    2
3753 #define SYS_wait    3
3754 #define SYS_pipe    4
3755 #define SYS_read    5
3756 #define SYS_kill    6
3757 #define SYS_exec    7
3758 #define SYS_fstat   8
3759 #define SYS_chdir   9
3760 #define SYS_dup    10
3761 #define SYS_getpid 11
3762 #define SYS_sbrk   12
3763 #define SYS_sleep  13
3764 #define SYS_uptime 14
3765 #define SYS_open   15
3766 #define SYS_write  16
3767 #define SYS_mknod  17
3768 #define SYS_unlink 18
3769 #define SYS_link   19
3770 #define SYS_mkdir  20
3771 #define SYS_close  21
3772 
3773 
3774 
3775 
3776 
3777 
3778 
3779 
3780 
3781 
3782 
3783 
3784 
3785 
3786 
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 #include "types.h"
3801 #include "defs.h"
3802 #include "param.h"
3803 #include "memlayout.h"
3804 #include "mmu.h"
3805 #include "proc.h"
3806 #include "syscall.h"
3807 #include "riscv.h"
3808 
3809 
3810 
3811 
3812 
3813 
3814 
3815 
3816 int
3817 fetchint(uint addr, int *ip)
3818 {
3819   struct proc *curproc = myproc();
3820 
3821   if(addr >= curproc->sz || addr+4 > curproc->sz)
3822     return -1;
3823   *ip = *(int*)(addr);
3824   return 0;
3825 }
3826 
3827 
3828 
3829 
3830 int
3831 fetchstr(uint addr, char **pp)
3832 {
3833   char *s, *ep;
3834   struct proc *curproc = myproc();
3835 
3836   if(addr >= curproc->sz)
3837     return -1;
3838   *pp = (char*)addr;
3839   ep = (char*)curproc->sz;
3840   for(s = *pp; s < ep; s++){
3841     if(*s == 0)
3842       return (s - *pp);
3843   }
3844   return -1;
3845 }
3846 
3847 
3848 
3849 
3850 
3851 int
3852 argint(int n, int *ip)
3853 {
3854 	
3855   return fetchint((myproc()->tf->sp) + 4 + 4*n, ip);
3856 }
3857 
3858 
3859 
3860 
3861 int
3862 argptr(int n, char **pp, int size)
3863 {
3864   int i;
3865   struct proc *curproc = myproc();
3866 
3867   if(argint(n, &i) < 0)
3868     return -1;
3869   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3870     return -1;
3871   *pp = (char*)i;
3872   return 0;
3873 }
3874 
3875 
3876 
3877 
3878 
3879 int
3880 argstr(int n, char **pp)
3881 {
3882   int addr;
3883   if(argint(n, &addr) < 0)
3884     return -1;
3885   return fetchstr(addr, pp);
3886 }
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 extern int sys_chdir(void);
3901 extern int sys_close(void);
3902 extern int sys_dup(void);
3903 extern int sys_exec(void);
3904 extern int sys_exit(void);
3905 extern int sys_fork(void);
3906 extern int sys_fstat(void);
3907 extern int sys_getpid(void);
3908 extern int sys_kill(void);
3909 extern int sys_link(void);
3910 extern int sys_mkdir(void);
3911 extern int sys_mknod(void);
3912 extern int sys_open(void);
3913 extern int sys_pipe(void);
3914 extern int sys_read(void);
3915 extern int sys_sbrk(void);
3916 extern int sys_sleep(void);
3917 extern int sys_unlink(void);
3918 extern int sys_wait(void);
3919 extern int sys_write(void);
3920 extern int sys_uptime(void);
3921 
3922 static int (*syscalls[])(void) = {
3923 [SYS_fork]    sys_fork,
3924 [SYS_exit]    sys_exit,
3925 [SYS_wait]    sys_wait,
3926 [SYS_pipe]    sys_pipe,
3927 [SYS_read]    sys_read,
3928 [SYS_kill]    sys_kill,
3929 [SYS_exec]    sys_exec,
3930 [SYS_fstat]   sys_fstat,
3931 [SYS_chdir]   sys_chdir,
3932 [SYS_dup]     sys_dup,
3933 [SYS_getpid]  sys_getpid,
3934 [SYS_sbrk]    sys_sbrk,
3935 [SYS_sleep]   sys_sleep,
3936 [SYS_uptime]  sys_uptime,
3937 [SYS_open]    sys_open,
3938 [SYS_write]   sys_write,
3939 [SYS_mknod]   sys_mknod,
3940 [SYS_unlink]  sys_unlink,
3941 [SYS_link]    sys_link,
3942 [SYS_mkdir]   sys_mkdir,
3943 [SYS_close]   sys_close,
3944 };
3945 
3946 
3947 
3948 
3949 
3950 void
3951 syscall(void)
3952 {
3953   int num;
3954   struct proc *curproc = myproc();
3955 
3956   
3957   num = curproc->tf->a0;
3958   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3959     
3960     curproc->tf->a0 = syscalls[num]();
3961   } else {
3962     cprintf("%d %s: unknown sys call %d\n",
3963             curproc->pid, curproc->name, num);
3964 	
3965     curproc->tf->a0 = -1;
3966   }
3967 }
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 #include "types.h"
4001 #include "riscv.h"
4002 #include "defs.h"
4003 #include "date.h"
4004 #include "param.h"
4005 #include "memlayout.h"
4006 #include "mmu.h"
4007 #include "proc.h"
4008 
4009 int
4010 sys_fork(void)
4011 {
4012   return fork();
4013 }
4014 
4015 int
4016 sys_exit(void)
4017 {
4018   exit();
4019   return 0;  
4020 }
4021 
4022 int
4023 sys_wait(void)
4024 {
4025   return wait();
4026 }
4027 
4028 int
4029 sys_kill(void)
4030 {
4031   int pid;
4032 
4033   if(argint(0, &pid) < 0)
4034     return -1;
4035   return kill(pid);
4036 }
4037 
4038 int
4039 sys_getpid(void)
4040 {
4041   return myproc()->pid;
4042 }
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 int
4051 sys_sbrk(void)
4052 {
4053   int addr;
4054   int n;
4055 
4056   if(argint(0, &n) < 0)
4057     return -1;
4058   addr = myproc()->sz;
4059   if(growproc(n) < 0)
4060     return -1;
4061   return addr;
4062 }
4063 
4064 int
4065 sys_sleep(void)
4066 {
4067   int n;
4068   uint ticks0;
4069 
4070   if(argint(0, &n) < 0)
4071     return -1;
4072   acquire(&tickslock);
4073   ticks0 = ticks;
4074   while(ticks - ticks0 < n){
4075     if(myproc()->killed){
4076       release(&tickslock);
4077       return -1;
4078     }
4079     sleep(&ticks, &tickslock);
4080   }
4081   release(&tickslock);
4082   return 0;
4083 }
4084 
4085 
4086 
4087 int
4088 sys_uptime(void)
4089 {
4090   uint xticks;
4091 
4092   acquire(&tickslock);
4093   xticks = ticks;
4094   release(&tickslock);
4095   return xticks;
4096 }
4097 
4098 
4099 
4100 struct buf {
4101   int flags;
4102   uint dev;
4103   uint blockno;
4104   struct sleeplock lock;
4105   uint refcnt;
4106   struct buf *prev; 
4107   struct buf *next;
4108   struct buf *qnext; 
4109   uchar data[BSIZE];
4110 };
4111 #define B_VALID 0x2  
4112 #define B_DIRTY 0x4  
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 struct sleeplock {
4152   uint locked;       
4153   struct spinlock lk; 
4154 
4155   
4156   char *name;        
4157   int pid;           
4158 };
4159 
4160 
4161 
4162 
4163 
4164 
4165 
4166 
4167 
4168 
4169 
4170 
4171 
4172 
4173 
4174 
4175 
4176 
4177 
4178 
4179 
4180 
4181 
4182 
4183 
4184 
4185 
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 #define O_RDONLY  0x000
4201 #define O_WRONLY  0x001
4202 #define O_RDWR    0x002
4203 #define O_CREATE  0x200
4204 
4205 
4206 
4207 
4208 
4209 
4210 
4211 
4212 
4213 
4214 
4215 
4216 
4217 
4218 
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 #define T_DIR  1   
4251 #define T_FILE 2   
4252 #define T_DEV  3   
4253 
4254 struct stat {
4255   short type;  
4256   int dev;     
4257   uint ino;    
4258   short nlink; 
4259   uint size;   
4260 };
4261 
4262 
4263 
4264 
4265 
4266 
4267 
4268 
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283 
4284 
4285 
4286 
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 
4303 
4304 #define ROOTINO 1  
4305 #define BSIZE 512  
4306 
4307 
4308 
4309 
4310 
4311 
4312 
4313 struct superblock {
4314   uint size;         
4315   uint nblocks;      
4316   uint ninodes;      
4317   uint nlog;         
4318   uint logstart;     
4319   uint inodestart;   
4320   uint bmapstart;    
4321 };
4322 
4323 #define NDIRECT 12
4324 #define NINDIRECT (BSIZE / sizeof(uint))
4325 #define MAXFILE (NDIRECT + NINDIRECT)
4326 
4327 
4328 struct dinode {
4329   short type;           
4330   short major;          
4331   short minor;          
4332   short nlink;          
4333   uint size;            
4334   uint addrs[NDIRECT+1];   
4335 };
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 #define IPB           (BSIZE / sizeof(struct dinode))
4352 
4353 
4354 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4355 
4356 
4357 #define BPB           (BSIZE*8)
4358 
4359 
4360 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4361 
4362 
4363 #define DIRSIZ 14
4364 
4365 struct dirent {
4366   ushort inum;
4367   char name[DIRSIZ];
4368 };
4369 
4370 
4371 
4372 
4373 
4374 
4375 
4376 
4377 
4378 
4379 
4380 
4381 
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 struct file {
4401   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4402   int ref; 
4403   char readable;
4404   char writable;
4405   struct pipe *pipe;
4406   struct inode *ip;
4407   uint off;
4408 };
4409 
4410 
4411 
4412 struct inode {
4413   uint dev;           
4414   uint inum;          
4415   int ref;            
4416   struct sleeplock lock; 
4417   int valid;          
4418 
4419   short type;         
4420   short major;
4421   short minor;
4422   short nlink;
4423   uint size;
4424   uint addrs[NDIRECT+1];
4425 };
4426 
4427 
4428 
4429 struct devsw {
4430   int (*read)(struct inode*, char*, int);
4431   int (*write)(struct inode*, char*, int);
4432 };
4433 
4434 extern struct devsw devsw[];
4435 
4436 #define CONSOLE 1
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 
4452 #include "types.h"
4453 #include "defs.h"
4454 #include "param.h"
4455 #include "memlayout.h"
4456 #include "mmu.h"
4457 #include "proc.h"
4458 #include "riscv.h"
4459 #include "traps.h"
4460 #include "spinlock.h"
4461 #include "sleeplock.h"
4462 #include "fs.h"
4463 #include "buf.h"
4464 
4465 #define SECTOR_SIZE   512
4466 #define IDE_BSY       0x80
4467 #define IDE_DRDY      0x40
4468 #define IDE_DF        0x20
4469 #define IDE_ERR       0x01
4470 
4471 #define IDE_CMD_READ  0x20
4472 #define IDE_CMD_WRITE 0x30
4473 #define IDE_CMD_RDMUL 0xc4
4474 #define IDE_CMD_WRMUL 0xc5
4475 
4476 
4477 
4478 
4479 
4480 static struct spinlock idelock;
4481 static struct buf *idequeue;
4482 
4483 static int havedisk1;
4484 static void idestart(struct buf*);
4485 
4486 
4487 static int
4488 idewait(int checkerr)
4489 {
4490   int r;
4491 
4492   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4493     ;
4494   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4495     return -1;
4496   return 0;
4497 }
4498 
4499 
4500 void
4501 ideinit(void)
4502 {
4503   int i;
4504 
4505   initlock(&idelock, "ide");
4506   ioapicenable(IRQ_IDE, ncpu - 1);
4507   idewait(0);
4508 
4509   
4510   outb(0x1f6, 0xe0 | (1<<4));
4511   for(i=0; i<1000; i++){
4512     if(inb(0x1f7) != 0){
4513       havedisk1 = 1;
4514       break;
4515     }
4516   }
4517 
4518   
4519   outb(0x1f6, 0xe0 | (0<<4));
4520 }
4521 
4522 
4523 static void
4524 idestart(struct buf *b)
4525 {
4526   if(b == 0)
4527     panic("idestart");
4528   if(b->blockno >= FSSIZE)
4529     panic("incorrect blockno");
4530   int sector_per_block =  BSIZE/SECTOR_SIZE;
4531   int sector = b->blockno * sector_per_block;
4532   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4533   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4534 
4535   if (sector_per_block > 7) panic("idestart");
4536 
4537   idewait(0);
4538   outb(0x3f6, 0);  
4539   outb(0x1f2, sector_per_block);  
4540   outb(0x1f3, sector & 0xff);
4541   outb(0x1f4, (sector >> 8) & 0xff);
4542   outb(0x1f5, (sector >> 16) & 0xff);
4543   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4544   if(b->flags & B_DIRTY){
4545     outb(0x1f7, write_cmd);
4546     outsl(0x1f0, b->data, BSIZE/4);
4547   } else {
4548     outb(0x1f7, read_cmd);
4549   }
4550 }
4551 
4552 
4553 void
4554 ideintr(void)
4555 {
4556   struct buf *b;
4557 
4558   
4559   acquire(&idelock);
4560 
4561   if((b = idequeue) == 0){
4562     release(&idelock);
4563     return;
4564   }
4565   idequeue = b->qnext;
4566 
4567   
4568   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4569     insl(0x1f0, b->data, BSIZE/4);
4570 
4571   
4572   b->flags |= B_VALID;
4573   b->flags &= ~B_DIRTY;
4574   wakeup(b);
4575 
4576   
4577   if(idequeue != 0)
4578     idestart(idequeue);
4579 
4580   release(&idelock);
4581 }
4582 
4583 
4584 
4585 
4586 
4587 
4588 
4589 
4590 
4591 
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 
4602 
4603 void
4604 iderw(struct buf *b)
4605 {
4606   struct buf **pp;
4607 
4608   if(!holdingsleep(&b->lock))
4609     panic("iderw: buf not locked");
4610   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4611     panic("iderw: nothing to do");
4612   if(b->dev != 0 && !havedisk1)
4613     panic("iderw: ide disk 1 not present");
4614 
4615   acquire(&idelock);  
4616 
4617   
4618   b->qnext = 0;
4619   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4620     ;
4621   *pp = b;
4622 
4623   
4624   if(idequeue == b)
4625     idestart(b);
4626 
4627   
4628   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4629     sleep(b, &idelock);
4630   }
4631 
4632 
4633   release(&idelock);
4634 }
4635 
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 
4653 
4654 
4655 
4656 
4657 
4658 
4659 
4660 
4661 
4662 
4663 
4664 
4665 
4666 
4667 
4668 
4669 
4670 #include "types.h"
4671 #include "defs.h"
4672 #include "param.h"
4673 #include "spinlock.h"
4674 #include "sleeplock.h"
4675 #include "fs.h"
4676 #include "buf.h"
4677 
4678 struct {
4679   struct spinlock lock;
4680   struct buf buf[NBUF];
4681 
4682   
4683   
4684   struct buf head;
4685 } bcache;
4686 
4687 void
4688 binit(void)
4689 {
4690   struct buf *b;
4691 
4692   initlock(&bcache.lock, "bcache");
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700   
4701   bcache.head.prev = &bcache.head;
4702   bcache.head.next = &bcache.head;
4703   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4704     b->next = bcache.head.next;
4705     b->prev = &bcache.head;
4706     initsleeplock(&b->lock, "buffer");
4707     bcache.head.next->prev = b;
4708     bcache.head.next = b;
4709   }
4710 }
4711 
4712 
4713 
4714 
4715 static struct buf*
4716 bget(uint dev, uint blockno)
4717 {
4718   struct buf *b;
4719 
4720   acquire(&bcache.lock);
4721 
4722   
4723   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4724     if(b->dev == dev && b->blockno == blockno){
4725       b->refcnt++;
4726       release(&bcache.lock);
4727       acquiresleep(&b->lock);
4728       return b;
4729     }
4730   }
4731 
4732   
4733   
4734   
4735   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4736     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4737       b->dev = dev;
4738       b->blockno = blockno;
4739       b->flags = 0;
4740       b->refcnt = 1;
4741       release(&bcache.lock);
4742       acquiresleep(&b->lock);
4743       return b;
4744     }
4745   }
4746   panic("bget: no buffers");
4747 }
4748 
4749 
4750 
4751 struct buf*
4752 bread(uint dev, uint blockno)
4753 {
4754   struct buf *b;
4755 
4756   b = bget(dev, blockno);
4757   if((b->flags & B_VALID) == 0) {
4758     iderw(b);
4759   }
4760   return b;
4761 }
4762 
4763 
4764 void
4765 bwrite(struct buf *b)
4766 {
4767   if(!holdingsleep(&b->lock))
4768     panic("bwrite");
4769   b->flags |= B_DIRTY;
4770   iderw(b);
4771 }
4772 
4773 
4774 
4775 void
4776 brelse(struct buf *b)
4777 {
4778   if(!holdingsleep(&b->lock))
4779     panic("brelse");
4780 
4781   releasesleep(&b->lock);
4782 
4783   acquire(&bcache.lock);
4784   b->refcnt--;
4785   if (b->refcnt == 0) {
4786     
4787     b->next->prev = b->prev;
4788     b->prev->next = b->next;
4789     b->next = bcache.head.next;
4790     b->prev = &bcache.head;
4791     bcache.head.next->prev = b;
4792     bcache.head.next = b;
4793   }
4794 
4795   release(&bcache.lock);
4796 }
4797 
4798 
4799 
4800 
4801 
4802 
4803 
4804 
4805 
4806 
4807 
4808 
4809 
4810 
4811 
4812 
4813 
4814 
4815 
4816 
4817 
4818 
4819 
4820 
4821 
4822 
4823 
4824 
4825 
4826 
4827 
4828 
4829 
4830 
4831 
4832 
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 
4845 
4846 
4847 
4848 
4849 
4850 
4851 
4852 #include "types.h"
4853 #include "defs.h"
4854 #include "param.h"
4855 #include "riscv.h"
4856 #include "memlayout.h"
4857 #include "mmu.h"
4858 #include "proc.h"
4859 #include "spinlock.h"
4860 #include "sleeplock.h"
4861 
4862 void
4863 initsleeplock(struct sleeplock *lk, char *name)
4864 {
4865   initlock(&lk->lk, "sleep lock");
4866   lk->name = name;
4867   lk->locked = 0;
4868   lk->pid = 0;
4869 }
4870 
4871 void
4872 acquiresleep(struct sleeplock *lk)
4873 {
4874   acquire(&lk->lk);
4875   while (lk->locked) {
4876     sleep(lk, &lk->lk);
4877   }
4878   lk->locked = 1;
4879   lk->pid = myproc()->pid;
4880   release(&lk->lk);
4881 }
4882 
4883 void
4884 releasesleep(struct sleeplock *lk)
4885 {
4886   acquire(&lk->lk);
4887   lk->locked = 0;
4888   lk->pid = 0;
4889   wakeup(lk);
4890   release(&lk->lk);
4891 }
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 int
4901 holdingsleep(struct sleeplock *lk)
4902 {
4903   int r;
4904 
4905   acquire(&lk->lk);
4906   r = lk->locked;
4907   release(&lk->lk);
4908   return r;
4909 }
4910 
4911 
4912 
4913 
4914 
4915 
4916 
4917 
4918 
4919 
4920 
4921 
4922 
4923 
4924 
4925 
4926 
4927 
4928 
4929 
4930 
4931 
4932 
4933 
4934 
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 #include "types.h"
4951 #include "defs.h"
4952 #include "param.h"
4953 #include "spinlock.h"
4954 #include "sleeplock.h"
4955 #include "fs.h"
4956 #include "buf.h"
4957 
4958 
4959 
4960 
4961 
4962 
4963 
4964 
4965 
4966 
4967 
4968 
4969 
4970 
4971 
4972 
4973 
4974 
4975 
4976 
4977 
4978 
4979 
4980 
4981 
4982 
4983 struct logheader {
4984   int n;
4985   int block[LOGSIZE];
4986 };
4987 
4988 struct log {
4989   struct spinlock lock;
4990   int start;
4991   int size;
4992   int outstanding; 
4993   int committing;  
4994   int dev;
4995   struct logheader lh;
4996 };
4997 
4998 
4999 
5000 struct log log;
5001 
5002 static void recover_from_log(void);
5003 static void commit();
5004 
5005 void
5006 initlog(int dev)
5007 {
5008   if (sizeof(struct logheader) >= BSIZE)
5009     panic("initlog: too big logheader");
5010 
5011   struct superblock sb;
5012   initlock(&log.lock, "log");
5013   readsb(dev, &sb);
5014   log.start = sb.logstart;
5015   log.size = sb.nlog;
5016   log.dev = dev;
5017   recover_from_log();
5018 }
5019 
5020 
5021 static void
5022 install_trans(void)
5023 {
5024   int tail;
5025 
5026   for (tail = 0; tail < log.lh.n; tail++) {
5027     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
5028     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
5029     memmove(dbuf->data, lbuf->data, BSIZE);  
5030     bwrite(dbuf);  
5031     brelse(lbuf);
5032     brelse(dbuf);
5033   }
5034 }
5035 
5036 
5037 static void
5038 read_head(void)
5039 {
5040   struct buf *buf = bread(log.dev, log.start);
5041   struct logheader *lh = (struct logheader *) (buf->data);
5042   int i;
5043   log.lh.n = lh->n;
5044   for (i = 0; i < log.lh.n; i++) {
5045     log.lh.block[i] = lh->block[i];
5046   }
5047   brelse(buf);
5048 }
5049 
5050 
5051 
5052 
5053 static void
5054 write_head(void)
5055 {
5056   struct buf *buf = bread(log.dev, log.start);
5057   struct logheader *hb = (struct logheader *) (buf->data);
5058   int i;
5059   hb->n = log.lh.n;
5060   for (i = 0; i < log.lh.n; i++) {
5061     hb->block[i] = log.lh.block[i];
5062   }
5063   bwrite(buf);
5064   brelse(buf);
5065 }
5066 
5067 static void
5068 recover_from_log(void)
5069 {
5070   read_head();
5071   install_trans(); 
5072   log.lh.n = 0;
5073   write_head(); 
5074 }
5075 
5076 
5077 void
5078 begin_op(void)
5079 {
5080   acquire(&log.lock);
5081   while(1){
5082     if(log.committing){
5083       sleep(&log, &log.lock);
5084     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
5085       
5086       sleep(&log, &log.lock);
5087     } else {
5088       log.outstanding += 1;
5089       release(&log.lock);
5090       break;
5091     }
5092   }
5093 }
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 
5102 void
5103 end_op(void)
5104 {
5105   int do_commit = 0;
5106 
5107   acquire(&log.lock);
5108   log.outstanding -= 1;
5109   if(log.committing)
5110     panic("log.committing");
5111   if(log.outstanding == 0){
5112     do_commit = 1;
5113     log.committing = 1;
5114   } else {
5115     
5116     
5117     
5118     wakeup(&log);
5119   }
5120   release(&log.lock);
5121 
5122   if(do_commit){
5123     
5124     
5125     commit();
5126     acquire(&log.lock);
5127     log.committing = 0;
5128     wakeup(&log);
5129     release(&log.lock);
5130   }
5131 }
5132 
5133 
5134 static void
5135 write_log(void)
5136 {
5137   int tail;
5138 
5139   for (tail = 0; tail < log.lh.n; tail++) {
5140     struct buf *to = bread(log.dev, log.start+tail+1); 
5141     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5142     memmove(to->data, from->data, BSIZE);
5143     bwrite(to);  
5144     brelse(from);
5145     brelse(to);
5146   }
5147 }
5148 
5149 
5150 static void
5151 commit()
5152 {
5153   if (log.lh.n > 0) {
5154     write_log();     
5155     write_head();    
5156     install_trans(); 
5157     log.lh.n = 0;
5158     write_head();    
5159   }
5160 }
5161 
5162 
5163 
5164 
5165 
5166 
5167 
5168 
5169 
5170 
5171 void
5172 log_write(struct buf *b)
5173 {
5174   int i;
5175 
5176   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5177     panic("too big a transaction");
5178   if (log.outstanding < 1)
5179     panic("log_write outside of trans");
5180 
5181   acquire(&log.lock);
5182   for (i = 0; i < log.lh.n; i++) {
5183     if (log.lh.block[i] == b->blockno)   
5184       break;
5185   }
5186   log.lh.block[i] = b->blockno;
5187   if (i == log.lh.n)
5188     log.lh.n++;
5189   b->flags |= B_DIRTY; 
5190   release(&log.lock);
5191 }
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 
5203 
5204 
5205 
5206 
5207 
5208 
5209 
5210 
5211 #include "types.h"
5212 #include "defs.h"
5213 #include "param.h"
5214 #include "stat.h"
5215 #include "mmu.h"
5216 #include "proc.h"
5217 #include "spinlock.h"
5218 #include "sleeplock.h"
5219 #include "fs.h"
5220 #include "buf.h"
5221 #include "file.h"
5222 
5223 #define min(a, b) ((a) < (b) ? (a) : (b))
5224 static void itrunc(struct inode*);
5225 
5226 
5227 struct superblock sb;
5228 
5229 
5230 void
5231 readsb(int dev, struct superblock *sb)
5232 {
5233   struct buf *bp;
5234 
5235   bp = bread(dev, 1);
5236   memmove(sb, bp->data, sizeof(*sb));
5237   brelse(bp);
5238 }
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 static void
5252 bzero(int dev, int bno)
5253 {
5254   struct buf *bp;
5255 
5256   bp = bread(dev, bno);
5257   memset(bp->data, 0, BSIZE);
5258   log_write(bp);
5259   brelse(bp);
5260 }
5261 
5262 
5263 
5264 
5265 static uint
5266 balloc(uint dev)
5267 {
5268   int b, bi, m;
5269   struct buf *bp;
5270 
5271   bp = 0;
5272   for(b = 0; b < sb.size; b += BPB){
5273     bp = bread(dev, BBLOCK(b, sb));
5274     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5275       m = 1 << (bi % 8);
5276       if((bp->data[bi/8] & m) == 0){  
5277         bp->data[bi/8] |= m;  
5278         log_write(bp);
5279         brelse(bp);
5280         bzero(dev, b + bi);
5281         return b + bi;
5282       }
5283     }
5284     brelse(bp);
5285   }
5286   panic("balloc: out of blocks");
5287 }
5288 
5289 
5290 
5291 
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 static void
5302 bfree(int dev, uint b)
5303 {
5304   struct buf *bp;
5305   int bi, m;
5306 
5307   readsb(dev, &sb);
5308   bp = bread(dev, BBLOCK(b, sb));
5309   bi = b % BPB;
5310   m = 1 << (bi % 8);
5311   if((bp->data[bi/8] & m) == 0)
5312     panic("freeing free block");
5313   bp->data[bi/8] &= ~m;
5314   log_write(bp);
5315   brelse(bp);
5316 }
5317 
5318 
5319 
5320 
5321 
5322 
5323 
5324 
5325 
5326 
5327 
5328 
5329 
5330 
5331 
5332 
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 
5352 
5353 
5354 
5355 
5356 
5357 
5358 
5359 
5360 
5361 
5362 
5363 
5364 
5365 
5366 
5367 
5368 
5369 
5370 
5371 
5372 
5373 
5374 
5375 
5376 
5377 
5378 
5379 
5380 
5381 
5382 
5383 
5384 
5385 
5386 
5387 struct {
5388   struct spinlock lock;
5389   struct inode inode[NINODE];
5390 } icache;
5391 
5392 void
5393 iinit(int dev)
5394 {
5395   int i = 0;
5396 
5397   initlock(&icache.lock, "icache");
5398   for(i = 0; i < NINODE; i++) {
5399     initsleeplock(&icache.inode[i].lock, "inode");
5400   }
5401 
5402   readsb(dev, &sb);
5403   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5404  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5405           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5406           sb.bmapstart);
5407 }
5408 
5409 static struct inode* iget(uint dev, uint inum);
5410 
5411 
5412 
5413 
5414 
5415 
5416 
5417 
5418 
5419 
5420 
5421 
5422 
5423 
5424 
5425 
5426 
5427 
5428 
5429 
5430 
5431 
5432 
5433 
5434 
5435 
5436 
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 struct inode*
5454 ialloc(uint dev, short type)
5455 {
5456   int inum;
5457   struct buf *bp;
5458   struct dinode *dip;
5459 
5460   for(inum = 1; inum < sb.ninodes; inum++){
5461     bp = bread(dev, IBLOCK(inum, sb));
5462     dip = (struct dinode*)bp->data + inum%IPB;
5463     if(dip->type == 0){  
5464       memset(dip, 0, sizeof(*dip));
5465       dip->type = type;
5466       log_write(bp);   
5467       brelse(bp);
5468       return iget(dev, inum);
5469     }
5470     brelse(bp);
5471   }
5472   panic("ialloc: no inodes");
5473 }
5474 
5475 
5476 
5477 
5478 
5479 void
5480 iupdate(struct inode *ip)
5481 {
5482   struct buf *bp;
5483   struct dinode *dip;
5484 
5485   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5486   dip = (struct dinode*)bp->data + ip->inum%IPB;
5487   dip->type = ip->type;
5488   dip->major = ip->major;
5489   dip->minor = ip->minor;
5490   dip->nlink = ip->nlink;
5491   dip->size = ip->size;
5492   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5493   log_write(bp);
5494   brelse(bp);
5495 }
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 static struct inode*
5504 iget(uint dev, uint inum)
5505 {
5506   struct inode *ip, *empty;
5507 
5508   acquire(&icache.lock);
5509 
5510   
5511   empty = 0;
5512   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5513     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5514       ip->ref++;
5515       release(&icache.lock);
5516       return ip;
5517     }
5518     if(empty == 0 && ip->ref == 0)    
5519       empty = ip;
5520   }
5521 
5522   
5523   if(empty == 0)
5524     panic("iget: no inodes");
5525 
5526   ip = empty;
5527   ip->dev = dev;
5528   ip->inum = inum;
5529   ip->ref = 1;
5530   ip->valid = 0;
5531   release(&icache.lock);
5532 
5533   return ip;
5534 }
5535 
5536 
5537 
5538 struct inode*
5539 idup(struct inode *ip)
5540 {
5541   acquire(&icache.lock);
5542   ip->ref++;
5543   release(&icache.lock);
5544   return ip;
5545 }
5546 
5547 
5548 
5549 
5550 
5551 
5552 void
5553 ilock(struct inode *ip)
5554 {
5555   struct buf *bp;
5556   struct dinode *dip;
5557 
5558   if(ip == 0 || ip->ref < 1)
5559     panic("ilock");
5560 
5561   acquiresleep(&ip->lock);
5562 
5563   if(ip->valid == 0){
5564     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5565     dip = (struct dinode*)bp->data + ip->inum%IPB;
5566     ip->type = dip->type;
5567     ip->major = dip->major;
5568     ip->minor = dip->minor;
5569     ip->nlink = dip->nlink;
5570     ip->size = dip->size;
5571     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5572     brelse(bp);
5573     ip->valid = 1;
5574     if(ip->type == 0)
5575       panic("ilock: no type");
5576   }
5577 }
5578 
5579 
5580 void
5581 iunlock(struct inode *ip)
5582 {
5583   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5584     panic("iunlock");
5585 
5586   releasesleep(&ip->lock);
5587 }
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 
5602 
5603 
5604 
5605 
5606 
5607 void
5608 iput(struct inode *ip)
5609 {
5610   acquiresleep(&ip->lock);
5611   if(ip->valid && ip->nlink == 0){
5612     acquire(&icache.lock);
5613     int r = ip->ref;
5614     release(&icache.lock);
5615     if(r == 1){
5616       
5617       itrunc(ip);
5618       ip->type = 0;
5619       iupdate(ip);
5620       ip->valid = 0;
5621     }
5622   }
5623   releasesleep(&ip->lock);
5624 
5625   acquire(&icache.lock);
5626   ip->ref--;
5627   release(&icache.lock);
5628 }
5629 
5630 
5631 void
5632 iunlockput(struct inode *ip)
5633 {
5634   iunlock(ip);
5635   iput(ip);
5636 }
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 
5651 
5652 
5653 
5654 
5655 
5656 
5657 
5658 
5659 static uint
5660 bmap(struct inode *ip, uint bn)
5661 {
5662   uint addr, *a;
5663   struct buf *bp;
5664 
5665   if(bn < NDIRECT){
5666     if((addr = ip->addrs[bn]) == 0)
5667       ip->addrs[bn] = addr = balloc(ip->dev);
5668     return addr;
5669   }
5670   bn -= NDIRECT;
5671 
5672   if(bn < NINDIRECT){
5673     
5674     if((addr = ip->addrs[NDIRECT]) == 0)
5675       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5676     bp = bread(ip->dev, addr);
5677     a = (uint*)bp->data;
5678     if((addr = a[bn]) == 0){
5679       a[bn] = addr = balloc(ip->dev);
5680       log_write(bp);
5681     }
5682     brelse(bp);
5683     return addr;
5684   }
5685 
5686   panic("bmap: out of range");
5687 }
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 
5702 
5703 
5704 
5705 static void
5706 itrunc(struct inode *ip)
5707 {
5708   int i, j;
5709   struct buf *bp;
5710   uint *a;
5711 
5712   for(i = 0; i < NDIRECT; i++){
5713     if(ip->addrs[i]){
5714       bfree(ip->dev, ip->addrs[i]);
5715       ip->addrs[i] = 0;
5716     }
5717   }
5718 
5719   if(ip->addrs[NDIRECT]){
5720     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5721     a = (uint*)bp->data;
5722     for(j = 0; j < NINDIRECT; j++){
5723       if(a[j])
5724         bfree(ip->dev, a[j]);
5725     }
5726     brelse(bp);
5727     bfree(ip->dev, ip->addrs[NDIRECT]);
5728     ip->addrs[NDIRECT] = 0;
5729   }
5730 
5731   ip->size = 0;
5732   iupdate(ip);
5733 }
5734 
5735 
5736 
5737 void
5738 stati(struct inode *ip, struct stat *st)
5739 {
5740   st->dev = ip->dev;
5741   st->ino = ip->inum;
5742   st->type = ip->type;
5743   st->nlink = ip->nlink;
5744   st->size = ip->size;
5745 }
5746 
5747 
5748 
5749 
5750 
5751 
5752 int
5753 readi(struct inode *ip, char *dst, uint off, uint n)
5754 {
5755   uint tot, m;
5756   struct buf *bp;
5757 
5758   if(ip->type == T_DEV){
5759     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5760       return -1;
5761     return devsw[ip->major].read(ip, dst, n);
5762   }
5763 
5764   if(off > ip->size || off + n < off)
5765     return -1;
5766   if(off + n > ip->size)
5767     n = ip->size - off;
5768 
5769   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5770     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5771     m = min(n - tot, BSIZE - off%BSIZE);
5772     memmove(dst, bp->data + off%BSIZE, m);
5773     brelse(bp);
5774   }
5775   return n;
5776 }
5777 
5778 
5779 
5780 
5781 
5782 
5783 
5784 
5785 
5786 
5787 
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 
5802 int
5803 writei(struct inode *ip, char *src, uint off, uint n)
5804 {
5805   uint tot, m;
5806   struct buf *bp;
5807 
5808   if(ip->type == T_DEV){
5809     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5810       return -1;
5811     return devsw[ip->major].write(ip, src, n);
5812   }
5813 
5814   if(off > ip->size || off + n < off)
5815     return -1;
5816   if(off + n > MAXFILE*BSIZE)
5817     return -1;
5818 
5819   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5820     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5821     m = min(n - tot, BSIZE - off%BSIZE);
5822     memmove(bp->data + off%BSIZE, src, m);
5823     log_write(bp);
5824     brelse(bp);
5825   }
5826 
5827   if(n > 0 && off > ip->size){
5828     ip->size = off;
5829     iupdate(ip);
5830   }
5831   return n;
5832 }
5833 
5834 
5835 
5836 
5837 
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 int
5853 namecmp(const char *s, const char *t)
5854 {
5855   return strncmp(s, t, DIRSIZ);
5856 }
5857 
5858 
5859 
5860 struct inode*
5861 dirlookup(struct inode *dp, char *name, uint *poff)
5862 {
5863   uint off, inum;
5864   struct dirent de;
5865 
5866   if(dp->type != T_DIR)
5867     panic("dirlookup not DIR");
5868 
5869   for(off = 0; off < dp->size; off += sizeof(de)){
5870     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5871       panic("dirlookup read");
5872     if(de.inum == 0)
5873       continue;
5874     if(namecmp(name, de.name) == 0){
5875       
5876       if(poff)
5877         *poff = off;
5878       inum = de.inum;
5879       return iget(dp->dev, inum);
5880     }
5881   }
5882 
5883   return 0;
5884 }
5885 
5886 
5887 
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 int
5902 dirlink(struct inode *dp, char *name, uint inum)
5903 {
5904   int off;
5905   struct dirent de;
5906   struct inode *ip;
5907 
5908   
5909   if((ip = dirlookup(dp, name, 0)) != 0){
5910     iput(ip);
5911     return -1;
5912   }
5913 
5914   
5915   for(off = 0; off < dp->size; off += sizeof(de)){
5916     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5917       panic("dirlink read");
5918     if(de.inum == 0)
5919       break;
5920   }
5921 
5922   strncpy(de.name, name, DIRSIZ);
5923   de.inum = inum;
5924   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5925     panic("dirlink");
5926 
5927   return 0;
5928 }
5929 
5930 
5931 
5932 
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 
5953 
5954 
5955 
5956 
5957 
5958 
5959 
5960 
5961 
5962 
5963 
5964 static char*
5965 skipelem(char *path, char *name)
5966 {
5967   char *s;
5968   int len;
5969 
5970   while(*path == '/')
5971     path++;
5972   if(*path == 0)
5973     return 0;
5974   s = path;
5975   while(*path != '/' && *path != 0)
5976     path++;
5977   len = path - s;
5978   if(len >= DIRSIZ)
5979     memmove(name, s, DIRSIZ);
5980   else {
5981     memmove(name, s, len);
5982     name[len] = 0;
5983   }
5984   while(*path == '/')
5985     path++;
5986   return path;
5987 }
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 
6002 
6003 
6004 static struct inode*
6005 namex(char *path, int nameiparent, char *name)
6006 {
6007   struct inode *ip, *next;
6008 
6009   if(*path == '/')
6010     ip = iget(ROOTDEV, ROOTINO);
6011   else
6012     ip = idup(myproc()->cwd);
6013 
6014   while((path = skipelem(path, name)) != 0){
6015     ilock(ip);
6016     if(ip->type != T_DIR){
6017       iunlockput(ip);
6018       return 0;
6019     }
6020     if(nameiparent && *path == '\0'){
6021       
6022       iunlock(ip);
6023       return ip;
6024     }
6025     if((next = dirlookup(ip, name, 0)) == 0){
6026       iunlockput(ip);
6027       return 0;
6028     }
6029     iunlockput(ip);
6030     ip = next;
6031   }
6032   if(nameiparent){
6033     iput(ip);
6034     return 0;
6035   }
6036   return ip;
6037 }
6038 
6039 struct inode*
6040 namei(char *path)
6041 {
6042   char name[DIRSIZ];
6043   return namex(path, 0, name);
6044 }
6045 
6046 
6047 
6048 
6049 
6050 struct inode*
6051 nameiparent(char *path, char *name)
6052 {
6053   return namex(path, 1, name);
6054 }
6055 
6056 
6057 
6058 
6059 
6060 
6061 
6062 
6063 
6064 
6065 
6066 
6067 
6068 
6069 
6070 
6071 
6072 
6073 
6074 
6075 
6076 
6077 
6078 
6079 
6080 
6081 
6082 
6083 
6084 
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 
6102 
6103 
6104 #include "types.h"
6105 #include "defs.h"
6106 #include "param.h"
6107 #include "fs.h"
6108 #include "spinlock.h"
6109 #include "sleeplock.h"
6110 #include "file.h"
6111 
6112 struct devsw devsw[NDEV];
6113 struct {
6114   struct spinlock lock;
6115   struct file file[NFILE];
6116 } ftable;
6117 
6118 void
6119 fileinit(void)
6120 {
6121   initlock(&ftable.lock, "ftable");
6122 }
6123 
6124 
6125 struct file*
6126 filealloc(void)
6127 {
6128   struct file *f;
6129 
6130   acquire(&ftable.lock);
6131   for(f = ftable.file; f < ftable.file + NFILE; f++){
6132     if(f->ref == 0){
6133       f->ref = 1;
6134       release(&ftable.lock);
6135       return f;
6136     }
6137   }
6138   release(&ftable.lock);
6139   return 0;
6140 }
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 struct file*
6152 filedup(struct file *f)
6153 {
6154   acquire(&ftable.lock);
6155   if(f->ref < 1)
6156     panic("filedup");
6157   f->ref++;
6158   release(&ftable.lock);
6159   return f;
6160 }
6161 
6162 
6163 void
6164 fileclose(struct file *f)
6165 {
6166   struct file ff;
6167 
6168   acquire(&ftable.lock);
6169   if(f->ref < 1)
6170     panic("fileclose");
6171   if(--f->ref > 0){
6172     release(&ftable.lock);
6173     return;
6174   }
6175   ff = *f;
6176   f->ref = 0;
6177   f->type = FD_NONE;
6178   release(&ftable.lock);
6179 
6180   if(ff.type == FD_PIPE)
6181     pipeclose(ff.pipe, ff.writable);
6182   else if(ff.type == FD_INODE){
6183     begin_op();
6184     iput(ff.ip);
6185     end_op();
6186   }
6187 }
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 int
6202 filestat(struct file *f, struct stat *st)
6203 {
6204   if(f->type == FD_INODE){
6205     ilock(f->ip);
6206     stati(f->ip, st);
6207     iunlock(f->ip);
6208     return 0;
6209   }
6210   return -1;
6211 }
6212 
6213 
6214 int
6215 fileread(struct file *f, char *addr, int n)
6216 {
6217   int r;
6218 
6219   if(f->readable == 0)
6220     return -1;
6221   if(f->type == FD_PIPE)
6222     return piperead(f->pipe, addr, n);
6223   if(f->type == FD_INODE){
6224     ilock(f->ip);
6225     if((r = readi(f->ip, addr, f->off, n)) > 0)
6226       f->off += r;
6227     iunlock(f->ip);
6228     return r;
6229   }
6230   panic("fileread");
6231 }
6232 
6233 
6234 
6235 
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 int
6252 filewrite(struct file *f, char *addr, int n)
6253 {
6254   int r;
6255 
6256   if(f->writable == 0)
6257     return -1;
6258   if(f->type == FD_PIPE)
6259     return pipewrite(f->pipe, addr, n);
6260   if(f->type == FD_INODE){
6261     
6262     
6263     
6264     
6265     
6266     
6267     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6268     int i = 0;
6269     while(i < n){
6270       int n1 = n - i;
6271       if(n1 > max)
6272         n1 = max;
6273 
6274       begin_op();
6275       ilock(f->ip);
6276       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6277         f->off += r;
6278       iunlock(f->ip);
6279       end_op();
6280 
6281       if(r < 0)
6282         break;
6283       if(r != n1)
6284         panic("short filewrite");
6285       i += r;
6286     }
6287     return i == n ? n : -1;
6288   }
6289   panic("filewrite");
6290 }
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 
6301 
6302 
6303 
6304 
6305 
6306 #include "types.h"
6307 #include "defs.h"
6308 #include "param.h"
6309 #include "stat.h"
6310 #include "mmu.h"
6311 #include "proc.h"
6312 #include "fs.h"
6313 #include "spinlock.h"
6314 #include "sleeplock.h"
6315 #include "file.h"
6316 #include "fcntl.h"
6317 
6318 
6319 
6320 static int
6321 argfd(int n, int *pfd, struct file **pf)
6322 {
6323   int fd;
6324   struct file *f;
6325 
6326   if(argint(n, &fd) < 0)
6327     return -1;
6328   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6329     return -1;
6330   if(pfd)
6331     *pfd = fd;
6332   if(pf)
6333     *pf = f;
6334   return 0;
6335 }
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 
6352 static int
6353 fdalloc(struct file *f)
6354 {
6355   int fd;
6356   struct proc *curproc = myproc();
6357 
6358   for(fd = 0; fd < NOFILE; fd++){
6359     if(curproc->ofile[fd] == 0){
6360       curproc->ofile[fd] = f;
6361       return fd;
6362     }
6363   }
6364   return -1;
6365 }
6366 
6367 int
6368 sys_dup(void)
6369 {
6370   struct file *f;
6371   int fd;
6372 
6373   if(argfd(0, 0, &f) < 0)
6374     return -1;
6375   if((fd=fdalloc(f)) < 0)
6376     return -1;
6377   filedup(f);
6378   return fd;
6379 }
6380 
6381 int
6382 sys_read(void)
6383 {
6384   struct file *f;
6385   int n;
6386   char *p;
6387 
6388   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6389     return -1;
6390   return fileread(f, p, n);
6391 }
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 int
6401 sys_write(void)
6402 {
6403   struct file *f;
6404   int n;
6405   char *p;
6406 
6407   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6408     return -1;
6409   return filewrite(f, p, n);
6410 }
6411 
6412 int
6413 sys_close(void)
6414 {
6415   int fd;
6416   struct file *f;
6417 
6418   if(argfd(0, &fd, &f) < 0)
6419     return -1;
6420   myproc()->ofile[fd] = 0;
6421   fileclose(f);
6422   return 0;
6423 }
6424 
6425 int
6426 sys_fstat(void)
6427 {
6428   struct file *f;
6429   struct stat *st;
6430 
6431   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6432     return -1;
6433   return filestat(f, st);
6434 }
6435 
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 int
6452 sys_link(void)
6453 {
6454   char name[DIRSIZ], *new, *old;
6455   struct inode *dp, *ip;
6456 
6457   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6458     return -1;
6459 
6460   begin_op();
6461   if((ip = namei(old)) == 0){
6462     end_op();
6463     return -1;
6464   }
6465 
6466   ilock(ip);
6467   if(ip->type == T_DIR){
6468     iunlockput(ip);
6469     end_op();
6470     return -1;
6471   }
6472 
6473   ip->nlink++;
6474   iupdate(ip);
6475   iunlock(ip);
6476 
6477   if((dp = nameiparent(new, name)) == 0)
6478     goto bad;
6479   ilock(dp);
6480   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6481     iunlockput(dp);
6482     goto bad;
6483   }
6484   iunlockput(dp);
6485   iput(ip);
6486 
6487   end_op();
6488 
6489   return 0;
6490 
6491 bad:
6492   ilock(ip);
6493   ip->nlink--;
6494   iupdate(ip);
6495   iunlockput(ip);
6496   end_op();
6497   return -1;
6498 }
6499 
6500 
6501 static int
6502 isdirempty(struct inode *dp)
6503 {
6504   int off;
6505   struct dirent de;
6506 
6507   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6508     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6509       panic("isdirempty: readi");
6510     if(de.inum != 0)
6511       return 0;
6512   }
6513   return 1;
6514 }
6515 
6516 
6517 
6518 
6519 
6520 
6521 
6522 
6523 
6524 
6525 
6526 
6527 
6528 
6529 
6530 
6531 
6532 
6533 
6534 
6535 
6536 
6537 
6538 
6539 
6540 
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 int
6551 sys_unlink(void)
6552 {
6553   struct inode *ip, *dp;
6554   struct dirent de;
6555   char name[DIRSIZ], *path;
6556   uint off;
6557 
6558   if(argstr(0, &path) < 0)
6559     return -1;
6560 
6561   begin_op();
6562   if((dp = nameiparent(path, name)) == 0){
6563     end_op();
6564     return -1;
6565   }
6566 
6567   ilock(dp);
6568 
6569   
6570   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6571     goto bad;
6572 
6573   if((ip = dirlookup(dp, name, &off)) == 0)
6574     goto bad;
6575   ilock(ip);
6576 
6577   if(ip->nlink < 1)
6578     panic("unlink: nlink < 1");
6579   if(ip->type == T_DIR && !isdirempty(ip)){
6580     iunlockput(ip);
6581     goto bad;
6582   }
6583 
6584   memset(&de, 0, sizeof(de));
6585   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6586     panic("unlink: writei");
6587   if(ip->type == T_DIR){
6588     dp->nlink--;
6589     iupdate(dp);
6590   }
6591   iunlockput(dp);
6592 
6593   ip->nlink--;
6594   iupdate(ip);
6595   iunlockput(ip);
6596 
6597   end_op();
6598 
6599   return 0;
6600 bad:
6601   iunlockput(dp);
6602   end_op();
6603   return -1;
6604 }
6605 
6606 static struct inode*
6607 create(char *path, short type, short major, short minor)
6608 {
6609   uint off;
6610   struct inode *ip, *dp;
6611   char name[DIRSIZ];
6612 
6613   if((dp = nameiparent(path, name)) == 0)
6614     return 0;
6615   ilock(dp);
6616 
6617   if((ip = dirlookup(dp, name, &off)) != 0){
6618     iunlockput(dp);
6619     ilock(ip);
6620     if(type == T_FILE && ip->type == T_FILE)
6621       return ip;
6622     iunlockput(ip);
6623     return 0;
6624   }
6625 
6626   if((ip = ialloc(dp->dev, type)) == 0)
6627     panic("create: ialloc");
6628 
6629   ilock(ip);
6630   ip->major = major;
6631   ip->minor = minor;
6632   ip->nlink = 1;
6633   iupdate(ip);
6634 
6635   if(type == T_DIR){  
6636     dp->nlink++;  
6637     iupdate(dp);
6638     
6639     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6640       panic("create dots");
6641   }
6642 
6643   if(dirlink(dp, name, ip->inum) < 0)
6644     panic("create: dirlink");
6645 
6646   iunlockput(dp);
6647 
6648   return ip;
6649 }
6650 int
6651 sys_open(void)
6652 {
6653   char *path;
6654   int fd, omode;
6655   struct file *f;
6656   struct inode *ip;
6657 
6658   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6659     return -1;
6660 
6661   begin_op();
6662 
6663   if(omode & O_CREATE){
6664     ip = create(path, T_FILE, 0, 0);
6665     if(ip == 0){
6666       end_op();
6667       return -1;
6668     }
6669   } else {
6670     if((ip = namei(path)) == 0){
6671       end_op();
6672       return -1;
6673     }
6674     ilock(ip);
6675     if(ip->type == T_DIR && omode != O_RDONLY){
6676       iunlockput(ip);
6677       end_op();
6678       return -1;
6679     }
6680   }
6681 
6682   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6683     if(f)
6684       fileclose(f);
6685     iunlockput(ip);
6686     end_op();
6687     return -1;
6688   }
6689   iunlock(ip);
6690   end_op();
6691 
6692   f->type = FD_INODE;
6693   f->ip = ip;
6694   f->off = 0;
6695   f->readable = !(omode & O_WRONLY);
6696   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6697   return fd;
6698 }
6699 
6700 int
6701 sys_mkdir(void)
6702 {
6703   char *path;
6704   struct inode *ip;
6705 
6706   begin_op();
6707   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6708     end_op();
6709     return -1;
6710   }
6711   iunlockput(ip);
6712   end_op();
6713   return 0;
6714 }
6715 
6716 int
6717 sys_mknod(void)
6718 {
6719   struct inode *ip;
6720   char *path;
6721   int major, minor;
6722 
6723   begin_op();
6724   if((argstr(0, &path)) < 0 ||
6725      argint(1, &major) < 0 ||
6726      argint(2, &minor) < 0 ||
6727      (ip = create(path, T_DEV, major, minor)) == 0){
6728     end_op();
6729     return -1;
6730   }
6731   iunlockput(ip);
6732   end_op();
6733   return 0;
6734 }
6735 
6736 
6737 
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 int
6751 sys_chdir(void)
6752 {
6753   char *path;
6754   struct inode *ip;
6755   struct proc *curproc = myproc();
6756 
6757   begin_op();
6758   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6759     end_op();
6760     return -1;
6761   }
6762   ilock(ip);
6763   if(ip->type != T_DIR){
6764     iunlockput(ip);
6765     end_op();
6766     return -1;
6767   }
6768   iunlock(ip);
6769   iput(curproc->cwd);
6770   end_op();
6771   curproc->cwd = ip;
6772   return 0;
6773 }
6774 
6775 int
6776 sys_exec(void)
6777 {
6778   char *path, *argv[MAXARG];
6779   int i;
6780   uint uargv, uarg;
6781 
6782   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6783     return -1;
6784   }
6785   memset(argv, 0, sizeof(argv));
6786   for(i=0;; i++){
6787     if(i >= NELEM(argv))
6788       return -1;
6789     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6790       return -1;
6791     if(uarg == 0){
6792       argv[i] = 0;
6793       break;
6794     }
6795     if(fetchstr(uarg, &argv[i]) < 0)
6796       return -1;
6797   }
6798   return exec(path, argv);
6799 }
6800 int
6801 sys_pipe(void)
6802 {
6803   int *fd;
6804   struct file *rf, *wf;
6805   int fd0, fd1;
6806 
6807   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6808     return -1;
6809   if(pipealloc(&rf, &wf) < 0)
6810     return -1;
6811   fd0 = -1;
6812   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6813     if(fd0 >= 0)
6814       myproc()->ofile[fd0] = 0;
6815     fileclose(rf);
6816     fileclose(wf);
6817     return -1;
6818   }
6819   fd[0] = fd0;
6820   fd[1] = fd1;
6821   return 0;
6822 }
6823 
6824 
6825 
6826 
6827 
6828 
6829 
6830 
6831 
6832 
6833 
6834 
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 #include "types.h"
6851 #include "param.h"
6852 #include "memlayout.h"
6853 #include "mmu.h"
6854 #include "proc.h"
6855 #include "defs.h"
6856 #include "elf.h"
6857 #include "riscv.h"
6858 
6859 int
6860 exec(char *path, char **argv)
6861 {
6862   char *s, *last;
6863   int i, off;
6864   uint argc, sz, sp, ustack[3+MAXARG+1];
6865   struct elfhdr elf;
6866   struct inode *ip;
6867   struct proghdr ph;
6868   pde_t *pgdir, *oldpgdir;
6869   struct proc *curproc = myproc();
6870 
6871   begin_op();
6872 
6873   if((ip = namei(path)) == 0){
6874     end_op();
6875     cprintf("exec: fail\n");
6876     return -1;
6877   }
6878   ilock(ip);
6879   pgdir = 0;
6880 
6881   
6882   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6883     goto bad;
6884   if(elf.magic != ELF_MAGIC)
6885     goto bad;
6886 
6887   if((pgdir = setupkvm()) == 0)
6888     goto bad;
6889 
6890   
6891   sz = 0;
6892   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6893     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6894       goto bad;
6895     if(ph.type != ELF_PROG_LOAD)
6896       continue;
6897     if(ph.memsz < ph.filesz)
6898       goto bad;
6899     if(ph.vaddr + ph.memsz < ph.vaddr)
6900       goto bad;
6901     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6902       goto bad;
6903     if(ph.vaddr % PGSIZE != 0)
6904       goto bad;
6905     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6906       goto bad;
6907   }
6908   iunlockput(ip);
6909   end_op();
6910   ip = 0;
6911 
6912   
6913   
6914   sz = PGROUNDUP(sz);
6915   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6916     goto bad;
6917   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6918   sp = sz;
6919 
6920   
6921   for(argc = 0; argv[argc]; argc++) {
6922     if(argc >= MAXARG)
6923       goto bad;
6924     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6925     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6926       goto bad;
6927     ustack[3+argc] = sp;
6928   }
6929   ustack[3+argc] = 0;
6930 
6931   ustack[0] = 0xffffffff;  
6932   ustack[1] = argc;
6933   ustack[2] = sp - (argc+1)*4;  
6934 
6935   sp -= (3+argc+1) * 4;
6936   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6937     goto bad;
6938 
6939   
6940   for(last=s=path; *s; s++)
6941     if(*s == '/')
6942       last = s+1;
6943   safestrcpy(curproc->name, last, sizeof(curproc->name));
6944 
6945   
6946   oldpgdir = curproc->pgdir;
6947   curproc->pgdir = pgdir;
6948   curproc->sz = sz;
6949   curproc->tf->mepc = elf.entry;  
6950   curproc->tf->sp = sp;
6951 
6952   curproc->tf->gp = sp;
6953   curproc->tf->t5 = ustack[1];
6954   curproc->tf->t6 = ustack[2];
6955 
6956   switchuvm(curproc);
6957   freevm(oldpgdir);
6958   return 0;
6959 
6960  bad:
6961   if(pgdir)
6962     freevm(pgdir);
6963   if(ip){
6964     iunlockput(ip);
6965     end_op();
6966   }
6967   return -1;
6968 }
6969 
6970 
6971 
6972 
6973 
6974 
6975 
6976 
6977 
6978 
6979 
6980 
6981 
6982 
6983 
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 #include "types.h"
7001 #include "defs.h"
7002 #include "param.h"
7003 #include "mmu.h"
7004 #include "proc.h"
7005 #include "fs.h"
7006 #include "spinlock.h"
7007 #include "sleeplock.h"
7008 #include "file.h"
7009 
7010 #define PIPESIZE 512
7011 
7012 struct pipe {
7013   struct spinlock lock;
7014   char data[PIPESIZE];
7015   uint nread;     
7016   uint nwrite;    
7017   int readopen;   
7018   int writeopen;  
7019 };
7020 
7021 int
7022 pipealloc(struct file **f0, struct file **f1)
7023 {
7024   struct pipe *p;
7025 
7026   p = 0;
7027   *f0 = *f1 = 0;
7028   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
7029     goto bad;
7030   if((p = (struct pipe*)kalloc()) == 0)
7031     goto bad;
7032   p->readopen = 1;
7033   p->writeopen = 1;
7034   p->nwrite = 0;
7035   p->nread = 0;
7036   initlock(&p->lock, "pipe");
7037   (*f0)->type = FD_PIPE;
7038   (*f0)->readable = 1;
7039   (*f0)->writable = 0;
7040   (*f0)->pipe = p;
7041   (*f1)->type = FD_PIPE;
7042   (*f1)->readable = 0;
7043   (*f1)->writable = 1;
7044   (*f1)->pipe = p;
7045   return 0;
7046 
7047 
7048 
7049 
7050  bad:
7051   if(p)
7052     kfree((char*)p);
7053   if(*f0)
7054     fileclose(*f0);
7055   if(*f1)
7056     fileclose(*f1);
7057   return -1;
7058 }
7059 
7060 void
7061 pipeclose(struct pipe *p, int writable)
7062 {
7063   acquire(&p->lock);
7064   if(writable){
7065     p->writeopen = 0;
7066     wakeup(&p->nread);
7067   } else {
7068     p->readopen = 0;
7069     wakeup(&p->nwrite);
7070   }
7071   if(p->readopen == 0 && p->writeopen == 0){
7072     release(&p->lock);
7073     kfree((char*)p);
7074   } else
7075     release(&p->lock);
7076 }
7077 
7078 
7079 int
7080 pipewrite(struct pipe *p, char *addr, int n)
7081 {
7082   int i;
7083 
7084   acquire(&p->lock);
7085   for(i = 0; i < n; i++){
7086     while(p->nwrite == p->nread + PIPESIZE){  
7087       if(p->readopen == 0 || myproc()->killed){
7088         release(&p->lock);
7089         return -1;
7090       }
7091       wakeup(&p->nread);
7092       sleep(&p->nwrite, &p->lock);  
7093     }
7094     p->data[p->nwrite++ % PIPESIZE] = addr[i];
7095   }
7096   wakeup(&p->nread);  
7097   release(&p->lock);
7098   return n;
7099 }
7100 int
7101 piperead(struct pipe *p, char *addr, int n)
7102 {
7103   int i;
7104 
7105   acquire(&p->lock);
7106   while(p->nread == p->nwrite && p->writeopen){  
7107     if(myproc()->killed){
7108       release(&p->lock);
7109       return -1;
7110     }
7111     sleep(&p->nread, &p->lock); 
7112   }
7113   for(i = 0; i < n; i++){  
7114     if(p->nread == p->nwrite)
7115       break;
7116     addr[i] = p->data[p->nread++ % PIPESIZE];
7117   }
7118   wakeup(&p->nwrite);  
7119   release(&p->lock);
7120   return i;
7121 }
7122 
7123 
7124 
7125 
7126 
7127 
7128 
7129 
7130 
7131 
7132 
7133 
7134 
7135 
7136 
7137 
7138 
7139 
7140 
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 #include "types.h"
7151 #include "riscv.h"
7152 
7153 void*
7154 memset(void *dst, int c, uint n)
7155 {
7156   if ((int)dst%4 == 0 && n%4 == 0){
7157     c &= 0xFF;
7158     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7159   } else
7160     stosb(dst, c, n);
7161   return dst;
7162 }
7163 
7164 int
7165 memcmp(const void *v1, const void *v2, uint n)
7166 {
7167   const uchar *s1, *s2;
7168 
7169   s1 = v1;
7170   s2 = v2;
7171   while(n-- > 0){
7172     if(*s1 != *s2)
7173       return *s1 - *s2;
7174     s1++, s2++;
7175   }
7176 
7177   return 0;
7178 }
7179 
7180 void*
7181 memmove(void *dst, const void *src, uint n)
7182 {
7183   const char *s;
7184   char *d;
7185 
7186   s = src;
7187   d = dst;
7188   if(s < d && s + n > d){
7189     s += n;
7190     d += n;
7191     while(n-- > 0)
7192       *--d = *--s;
7193   } else
7194     while(n-- > 0)
7195       *d++ = *s++;
7196 
7197   return dst;
7198 }
7199 
7200 
7201 void*
7202 memcpy(void *dst, const void *src, uint n)
7203 {
7204   return memmove(dst, src, n);
7205 }
7206 
7207 int
7208 strncmp(const char *p, const char *q, uint n)
7209 {
7210   while(n > 0 && *p && *p == *q)
7211     n--, p++, q++;
7212   if(n == 0)
7213     return 0;
7214   return (uchar)*p - (uchar)*q;
7215 }
7216 
7217 char*
7218 strncpy(char *s, const char *t, int n)
7219 {
7220   char *os;
7221 
7222   os = s;
7223   while(n-- > 0 && (*s++ = *t++) != 0)
7224     ;
7225   while(n-- > 0)
7226     *s++ = 0;
7227   return os;
7228 }
7229 
7230 
7231 char*
7232 safestrcpy(char *s, const char *t, int n)
7233 {
7234   char *os;
7235 
7236   os = s;
7237   if(n <= 0)
7238     return os;
7239   while(--n > 0 && (*s++ = *t++) != 0)
7240     ;
7241   *s = 0;
7242   return os;
7243 }
7244 
7245 
7246 
7247 
7248 
7249 
7250 int
7251 strlen(const char *s)
7252 {
7253   int n;
7254 
7255   for(n = 0; s[n]; n++)
7256     ;
7257   return n;
7258 }
7259 
7260 
7261 
7262 
7263 
7264 
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 
7301 
7302 struct mp {             
7303   uchar signature[4];           
7304   void *physaddr;               
7305   uchar length;                 
7306   uchar specrev;                
7307   uchar checksum;               
7308   uchar type;                   
7309   uchar imcrp;
7310   uchar reserved[3];
7311 };
7312 
7313 struct mpconf {         
7314   uchar signature[4];           
7315   ushort length;                
7316   uchar version;                
7317   uchar checksum;               
7318   uchar product[20];            
7319   uint *oemtable;               
7320   ushort oemlength;             
7321   ushort entry;                 
7322   uint *lapicaddr;              
7323   ushort xlength;               
7324   uchar xchecksum;              
7325   uchar reserved;
7326 };
7327 
7328 struct mpproc {         
7329   uchar type;                   
7330   uchar apicid;                 
7331   uchar version;                
7332   uchar flags;                  
7333     #define MPBOOT 0x02           
7334   uchar signature[4];           
7335   uint feature;                 
7336   uchar reserved[8];
7337 };
7338 
7339 struct mpioapic {       
7340   uchar type;                   
7341   uchar apicno;                 
7342   uchar version;                
7343   uchar flags;                  
7344   uint *addr;                  
7345 };
7346 
7347 
7348 
7349 
7350 
7351 #define MPPROC    0x00  
7352 #define MPBUS     0x01  
7353 #define MPIOAPIC  0x02  
7354 #define MPIOINTR  0x03  
7355 #define MPLINTR   0x04  
7356 
7357 
7358 
7359 
7360 
7361 
7362 
7363 
7364 
7365 
7366 
7367 
7368 
7369 
7370 
7371 
7372 
7373 
7374 
7375 
7376 
7377 
7378 
7379 
7380 
7381 
7382 
7383 
7384 
7385 
7386 
7387 
7388 
7389 
7390 
7391 
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 
7401 
7402 
7403 
7404 
7405 
7406 
7407 
7408 
7409 
7410 
7411 
7412 
7413 
7414 
7415 
7416 
7417 
7418 
7419 
7420 
7421 
7422 
7423 
7424 
7425 
7426 
7427 
7428 
7429 
7430 
7431 
7432 
7433 
7434 
7435 
7436 
7437 
7438 
7439 
7440 
7441 
7442 
7443 
7444 
7445 
7446 
7447 
7448 
7449 
7450 
7451 
7452 
7453 #include "types.h"
7454 #include "defs.h"
7455 #include "param.h"
7456 #include "memlayout.h"
7457 #include "mp.h"
7458 #include "mmu.h"
7459 #include "proc.h"
7460 #include "riscv.h"
7461 
7462 struct cpu cpus[NCPU];
7463 int ncpu;
7464 uchar ioapicid;
7465 
7466 static uchar
7467 sum(uchar *addr, int len)
7468 {
7469   int i, sum;
7470 
7471   sum = 0;
7472   for(i=0; i<len; i++)
7473     sum += addr[i];
7474   return sum;
7475 }
7476 
7477 
7478 static struct mp*
7479 mpsearch1(uint a, int len)
7480 {
7481   uchar *e, *p, *addr;
7482 
7483   addr = P2V(a);
7484   e = addr+len;
7485   for(p = addr; p < e; p += sizeof(struct mp))
7486     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7487       return (struct mp*)p;
7488   return 0;
7489 }
7490 
7491 
7492 
7493 
7494 
7495 
7496 
7497 
7498 
7499 
7500 
7501 
7502 
7503 
7504 
7505 static struct mp*
7506 mpsearch(void)
7507 {
7508   uchar *bda;
7509   uint p;
7510   struct mp *mp;
7511 
7512   bda = (uchar *) P2V(0x400);
7513   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7514     if((mp = mpsearch1(p, 1024)))
7515       return mp;
7516   } else {
7517     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7518     if((mp = mpsearch1(p-1024, 1024)))
7519       return mp;
7520   }
7521   return mpsearch1(0xF0000, 0x10000);
7522 }
7523 
7524 
7525 
7526 
7527 
7528 
7529 static struct mpconf*
7530 mpconfig(struct mp **pmp)
7531 {
7532   struct mpconf *conf;
7533   struct mp *mp;
7534 
7535   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7536     return 0;
7537   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7538   if(memcmp(conf, "PCMP", 4) != 0)
7539     return 0;
7540   if(conf->version != 1 && conf->version != 4)
7541     return 0;
7542   if(sum((uchar*)conf, conf->length) != 0)
7543     return 0;
7544   *pmp = mp;
7545   return conf;
7546 }
7547 
7548 
7549 
7550 void
7551 mpinit(void)
7552 {
7553   uchar *p, *e;
7554   int ismp;
7555   struct mp *mp;
7556   struct mpconf *conf;
7557   struct mpproc *proc;
7558   struct mpioapic *ioapic;
7559 
7560   if((conf = mpconfig(&mp)) == 0)
7561     panic("Expect to run on an SMP");
7562   ismp = 1;
7563   lapic = (uint*)conf->lapicaddr;
7564   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7565     switch(*p){
7566     case MPPROC:
7567       proc = (struct mpproc*)p;
7568       if(ncpu < NCPU) {
7569         cpus[ncpu].apicid = proc->apicid;  
7570         ncpu++;
7571       }
7572       p += sizeof(struct mpproc);
7573       continue;
7574     case MPIOAPIC:
7575       ioapic = (struct mpioapic*)p;
7576       ioapicid = ioapic->apicno;
7577       p += sizeof(struct mpioapic);
7578       continue;
7579     case MPBUS:
7580     case MPIOINTR:
7581     case MPLINTR:
7582       p += 8;
7583       continue;
7584     default:
7585       ismp = 0;
7586       break;
7587     }
7588   }
7589   if(!ismp)
7590     panic("Didn't find a suitable machine");
7591 
7592   if(mp->imcrp){
7593     
7594     
7595     outb(0x22, 0x70);   
7596     outb(0x23, inb(0x23) | 1);  
7597   }
7598 
7599 }
7600 
7601 
7602 
7603 #include "param.h"
7604 #include "types.h"
7605 #include "defs.h"
7606 #include "date.h"
7607 #include "memlayout.h"
7608 #include "traps.h"
7609 #include "mmu.h"
7610 #include "riscv.h"
7611 
7612 
7613 
7614 #define ID      (0x0020/4)   
7615 #define VER     (0x0030/4)   
7616 #define TPR     (0x0080/4)   
7617 #define EOI     (0x00B0/4)   
7618 #define SVR     (0x00F0/4)   
7619   #define ENABLE     0x00000100   
7620 #define ESR     (0x0280/4)   
7621 #define ICRLO   (0x0300/4)   
7622   #define INIT       0x00000500   
7623   #define STARTUP    0x00000600   
7624   #define DELIVS     0x00001000   
7625   #define ASSERT     0x00004000   
7626   #define DEASSERT   0x00000000
7627   #define LEVEL      0x00008000   
7628   #define BCAST      0x00080000   
7629   #define BUSY       0x00001000
7630   #define FIXED      0x00000000
7631 #define ICRHI   (0x0310/4)   
7632 
7633   #define X1         0x0000000B   
7634   #define PERIODIC   0x00020000   
7635 #define PCINT   (0x0340/4)   
7636 #define LINT0   (0x0350/4)   
7637 #define LINT1   (0x0360/4)   
7638 #define ERROR   (0x0370/4)   
7639   #define MASKED     0x00010000   
7640 #define TICR    (0x0380/4)   
7641 #define TCCR    (0x0390/4)   
7642 #define TDCR    (0x03E0/4)   
7643 
7644 volatile uint *lapic;  
7645 
7646 
7647 
7648 
7649 
7650 static void
7651 lapicw(int index, int value)
7652 {
7653   lapic[index] = value;
7654   lapic[ID];  
7655 }
7656 
7657 void
7658 lapicinit(void)
7659 {
7660   
7661   
7662   set_timecmp(FREQ_L(100),0);
7663   set_timecmp(0,1);
7664   en_intr(TIMER);
7665   en_intr(EXTERNAL);
7666 /*
7667   
7668   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7669 
7670   
7671   
7672   
7673   
7674   lapicw(TDCR, X1);
7675   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7676   lapicw(TICR, 10000000);
7677 
7678   
7679   lapicw(LINT0, MASKED);
7680   lapicw(LINT1, MASKED);
7681 
7682   
7683   
7684   if(((lapic[VER]>>16) & 0xFF) >= 4)
7685     lapicw(PCINT, MASKED);
7686 
7687   
7688   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7689 
7690   
7691   lapicw(ESR, 0);
7692   lapicw(ESR, 0);
7693 
7694   
7695   lapicw(EOI, 0);
7696 
7697 
7698 
7699 
7700   
7701   lapicw(ICRHI, 0);
7702   lapicw(ICRLO, BCAST | INIT | LEVEL);
7703   while(lapic[ICRLO] & DELIVS)
7704     ;
7705 
7706   
7707   lapicw(TPR, 0);
7708   */
7709 }
7710 
7711 int
7712 lapicid(void)
7713 {
7714   if (!lapic)
7715     return 0;
7716   return lapic[ID] >> 24;
7717 }
7718 
7719 
7720 void
7721 lapiceoi(void)
7722 {
7723   if(lapic)
7724     lapicw(EOI, 0);
7725 }
7726 
7727 
7728 
7729 void
7730 microdelay(int us)
7731 {
7732 }
7733 
7734 #define CMOS_PORT    0x70
7735 #define CMOS_RETURN  0x71
7736 
7737 
7738 
7739 void
7740 lapicstartap(uchar apicid, uint addr)
7741 {
7742   int i;
7743   ushort *wrv;
7744 
7745   
7746   
7747   
7748   outb(CMOS_PORT, 0xF);  
7749   outb(CMOS_PORT+1, 0x0A);
7750   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7751   wrv[0] = 0;
7752   wrv[1] = addr >> 4;
7753 
7754   
7755   
7756   lapicw(ICRHI, apicid<<24);
7757   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7758   microdelay(200);
7759   lapicw(ICRLO, INIT | LEVEL);
7760   microdelay(100);    
7761 
7762   
7763   
7764   
7765   
7766   
7767   for(i = 0; i < 2; i++){
7768     lapicw(ICRHI, apicid<<24);
7769     lapicw(ICRLO, STARTUP | (addr>>12));
7770     microdelay(200);
7771   }
7772 }
7773 
7774 #define CMOS_STATA   0x0a
7775 #define CMOS_STATB   0x0b
7776 #define CMOS_UIP    (1 << 7)        
7777 
7778 #define SECS    0x00
7779 #define MINS    0x02
7780 #define HOURS   0x04
7781 #define DAY     0x07
7782 #define MONTH   0x08
7783 #define YEAR    0x09
7784 
7785 static uint cmos_read(uint reg)
7786 {
7787   outb(CMOS_PORT,  reg);
7788   microdelay(200);
7789 
7790   return inb(CMOS_RETURN);
7791 }
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 static void fill_rtcdate(struct rtcdate *r)
7801 {
7802   r->second = cmos_read(SECS);
7803   r->minute = cmos_read(MINS);
7804   r->hour   = cmos_read(HOURS);
7805   r->day    = cmos_read(DAY);
7806   r->month  = cmos_read(MONTH);
7807   r->year   = cmos_read(YEAR);
7808 }
7809 
7810 
7811 void cmostime(struct rtcdate *r)
7812 {
7813   struct rtcdate t1, t2;
7814   int sb, bcd;
7815 
7816   sb = cmos_read(CMOS_STATB);
7817 
7818   bcd = (sb & (1 << 2)) == 0;
7819 
7820   
7821   for(;;) {
7822     fill_rtcdate(&t1);
7823     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7824         continue;
7825     fill_rtcdate(&t2);
7826     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7827       break;
7828   }
7829 
7830   
7831   if(bcd) {
7832 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7833     CONV(second);
7834     CONV(minute);
7835     CONV(hour  );
7836     CONV(day   );
7837     CONV(month );
7838     CONV(year  );
7839 #undef     CONV
7840   }
7841 
7842   *r = t1;
7843   r->year += 2000;
7844 }
7845 
7846 
7847 
7848 
7849 
7850 
7851 
7852 
7853 
7854 #include "types.h"
7855 #include "defs.h"
7856 #include "traps.h"
7857 
7858 #define IOAPIC  0xFEC00000   
7859 
7860 #define REG_ID     0x00  
7861 #define REG_VER    0x01  
7862 #define REG_TABLE  0x10  
7863 
7864 
7865 
7866 
7867 
7868 
7869 #define INT_DISABLED   0x00010000  
7870 #define INT_LEVEL      0x00008000  
7871 #define INT_ACTIVELOW  0x00002000  
7872 #define INT_LOGICAL    0x00000800  
7873 
7874 volatile struct ioapic *ioapic;
7875 
7876 
7877 struct ioapic {
7878   uint reg;
7879   uint pad[3];
7880   uint data;
7881 };
7882 
7883 static uint
7884 ioapicread(int reg)
7885 {
7886   ioapic->reg = reg;
7887   return ioapic->data;
7888 }
7889 
7890 static void
7891 ioapicwrite(int reg, uint data)
7892 {
7893   ioapic->reg = reg;
7894   ioapic->data = data;
7895 }
7896 
7897 
7898 
7899 
7900 void
7901 ioapicinit(void)
7902 {
7903   int i, id, maxintr;
7904 
7905   ioapic = (volatile struct ioapic*)IOAPIC;
7906   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7907   id = ioapicread(REG_ID) >> 24;
7908   if(id != ioapicid)
7909     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7910 
7911   
7912   
7913   for(i = 0; i <= maxintr; i++){
7914     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7915     ioapicwrite(REG_TABLE+2*i+1, 0);
7916   }
7917 }
7918 
7919 void
7920 ioapicenable(int irq, int cpunum)
7921 {
7922   
7923   
7924   
7925   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7926   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7927 }
7928 
7929 
7930 
7931 
7932 
7933 
7934 
7935 
7936 
7937 
7938 
7939 
7940 
7941 
7942 
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 
7951 
7952 #define KBSTATP         0x64    
7953 #define KBS_DIB         0x01    
7954 #define KBDATAP         0x60    
7955 
7956 #define NO              0
7957 
7958 #define SHIFT           (1<<0)
7959 #define CTL             (1<<1)
7960 #define ALT             (1<<2)
7961 
7962 #define CAPSLOCK        (1<<3)
7963 #define NUMLOCK         (1<<4)
7964 #define SCROLLLOCK      (1<<5)
7965 
7966 #define E0ESC           (1<<6)
7967 
7968 
7969 #define KEY_HOME        0xE0
7970 #define KEY_END         0xE1
7971 #define KEY_UP          0xE2
7972 #define KEY_DN          0xE3
7973 #define KEY_LF          0xE4
7974 #define KEY_RT          0xE5
7975 #define KEY_PGUP        0xE6
7976 #define KEY_PGDN        0xE7
7977 #define KEY_INS         0xE8
7978 #define KEY_DEL         0xE9
7979 
7980 
7981 #define C(x) (x - '@')
7982 
7983 static uchar shiftcode[256] =
7984 {
7985   [0x1D] CTL,
7986   [0x2A] SHIFT,
7987   [0x36] SHIFT,
7988   [0x38] ALT,
7989   [0x9D] CTL,
7990   [0xB8] ALT
7991 };
7992 
7993 static uchar togglecode[256] =
7994 {
7995   [0x3A] CAPSLOCK,
7996   [0x45] NUMLOCK,
7997   [0x46] SCROLLLOCK
7998 };
7999 
8000 static uchar normalmap[256] =
8001 {
8002   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
8003   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
8004   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
8005   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
8006   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
8007   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
8008   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
8009   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8010   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8011   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8012   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8013   [0x9C] '\n',      
8014   [0xB5] '/',       
8015   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8016   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8017   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8018   [0x97] KEY_HOME,  [0xCF] KEY_END,
8019   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8020 };
8021 
8022 static uchar shiftmap[256] =
8023 {
8024   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
8025   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
8026   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
8027   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
8028   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
8029   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
8030   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
8031   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8032   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8033   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8034   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8035   [0x9C] '\n',      
8036   [0xB5] '/',       
8037   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8038   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8039   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8040   [0x97] KEY_HOME,  [0xCF] KEY_END,
8041   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8042 };
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 static uchar ctlmap[256] =
8051 {
8052   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8053   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8054   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
8055   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
8056   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
8057   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
8058   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
8059   [0x9C] '\r',      
8060   [0xB5] C('/'),    
8061   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8062   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8063   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8064   [0x97] KEY_HOME,  [0xCF] KEY_END,
8065   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8066 };
8067 
8068 
8069 
8070 
8071 
8072 
8073 
8074 
8075 
8076 
8077 
8078 
8079 
8080 
8081 
8082 
8083 
8084 
8085 
8086 
8087 
8088 
8089 
8090 
8091 
8092 
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 #include "types.h"
8101 #include "defs.h"
8102 #include "kbd.h"
8103 #include "riscv.h"
8104 
8105 int
8106 kbdgetc(void)
8107 {
8108   static uint shift;
8109   static uchar *charcode[4] = {
8110     normalmap, shiftmap, ctlmap, ctlmap
8111   };
8112   uint st, data, c;
8113 
8114   st = inb(KBSTATP);
8115   if((st & KBS_DIB) == 0)
8116     return -1;
8117   data = inb(KBDATAP);
8118 
8119   if(data == 0xE0){
8120     shift |= E0ESC;
8121     return 0;
8122   } else if(data & 0x80){
8123     
8124     data = (shift & E0ESC ? data : data & 0x7F);
8125     shift &= ~(shiftcode[data] | E0ESC);
8126     return 0;
8127   } else if(shift & E0ESC){
8128     
8129     data |= 0x80;
8130     shift &= ~E0ESC;
8131   }
8132 
8133   shift |= shiftcode[data];
8134   shift ^= togglecode[data];
8135   c = charcode[shift & (CTL | SHIFT)][data];
8136   if(shift & CAPSLOCK){
8137     if('a' <= c && c <= 'z')
8138       c += 'A' - 'a';
8139     else if('A' <= c && c <= 'Z')
8140       c += 'a' - 'A';
8141   }
8142   return c;
8143 }
8144 
8145 void
8146 kbdintr(void)
8147 {
8148   consoleintr(kbdgetc);
8149 }
8150 
8151 
8152 
8153 
8154 #include "types.h"
8155 #include "defs.h"
8156 #include "param.h"
8157 #include "traps.h"
8158 #include "spinlock.h"
8159 #include "sleeplock.h"
8160 #include "fs.h"
8161 #include "file.h"
8162 #include "memlayout.h"
8163 #include "mmu.h"
8164 #include "proc.h"
8165 #include "riscv.h"
8166 
8167 
8168 static void consputc(int);
8169 
8170 static int panicked = 0;
8171 
8172 static struct {
8173   struct spinlock lock;
8174   int locking;
8175 } cons;
8176 
8177 static void
8178 printint(int xx, int base, int sign)
8179 {
8180   static char digits[] = "0123456789abcdef";
8181   char buf[16];
8182   int i;
8183   uint x;
8184 
8185   if(sign && (sign = xx < 0))
8186     x = -xx;
8187   else
8188     x = xx;
8189 
8190   i = 0;
8191   do{
8192     buf[i++] = digits[x % base];
8193   }while((x /= base) != 0);
8194 
8195   if(sign)
8196     buf[i++] = '-';
8197 
8198 
8199 
8200   while(--i >= 0)
8201     consputc(buf[i]);
8202 }
8203 
8204 
8205 
8206 
8207 
8208 
8209 
8210 
8211 
8212 
8213 
8214 
8215 
8216 
8217 
8218 
8219 
8220 
8221 
8222 
8223 
8224 
8225 
8226 
8227 
8228 
8229 
8230 
8231 
8232 
8233 
8234 
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 void
8252 cprintf(char *fmt, ...)
8253 {
8254   int i, c, locking;
8255   uint *argp;
8256   char *s;
8257 
8258   locking = cons.locking;
8259   if(locking)
8260     acquire(&cons.lock);
8261 
8262   if (fmt == 0)
8263     panic("null fmt");
8264 
8265   asm volatile("mv %0,s0" : "=r"(argp));
8266   argp++;
8267   
8268   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8269     if(c != '%'){
8270       consputc(c);
8271       continue;
8272     }
8273     c = fmt[++i] & 0xff;
8274     if(c == 0)
8275       break;
8276     switch(c){
8277     case 'd':
8278       printint(*argp++, 10, 1);
8279       break;
8280     case 'x':
8281     case 'p':
8282       printint(*argp++, 16, 0);
8283       break;
8284     case 's':
8285       if((s = (char*)*argp++) == 0)
8286         s = "(null)";
8287       for(; *s; s++)
8288         consputc(*s);
8289       break;
8290     case '%':
8291       consputc('%');
8292       break;
8293     default:
8294       
8295       consputc('%');
8296       consputc(c);
8297       break;
8298     }
8299   }
8300   if(locking)
8301     release(&cons.lock);
8302 }
8303 
8304 void
8305 panic(char *s)
8306 {
8307   int i;
8308   uint pcs[10];
8309 
8310   cli();
8311   cons.locking = 0;
8312   
8313   cprintf("lapicid %d: panic: ", lapicid());
8314   cprintf(s);
8315   cprintf("\n");
8316   getcallerpcs(&s, pcs);
8317   for(i=0; i<10; i++)
8318     cprintf(" %p", pcs[i]);
8319   panicked = 1; 
8320   for(;;)
8321     ;
8322 }
8323 
8324 
8325 
8326 
8327 
8328 
8329 
8330 
8331 
8332 
8333 
8334 
8335 
8336 
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 #define BACKSPACE 0x100
8351 #define CRTPORT 0x3d4
8352 static ushort *crt = (ushort*)P2V(0xb8000);  
8353 
8354 static void
8355 cgaputc(int c)
8356 {
8357   int pos;
8358 
8359   
8360   outb(CRTPORT, 14);
8361   pos = inb(CRTPORT+1) << 8;
8362   outb(CRTPORT, 15);
8363   pos |= inb(CRTPORT+1);
8364 
8365   if(c == '\n')
8366     pos += 80 - pos%80;
8367   else if(c == BACKSPACE){
8368     if(pos > 0) --pos;
8369   } else
8370     crt[pos++] = (c&0xff) | 0x0700;  
8371 
8372   if(pos < 0 || pos > 25*80)
8373     panic("pos under/overflow");
8374 
8375   if((pos/80) >= 24){  
8376     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8377     pos -= 80;
8378     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8379   }
8380 
8381   outb(CRTPORT, 14);
8382   outb(CRTPORT+1, pos>>8);
8383   outb(CRTPORT, 15);
8384   outb(CRTPORT+1, pos);
8385   crt[pos] = ' ' | 0x0700;
8386 }
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 void
8401 consputc(int c)
8402 {
8403   if(panicked){
8404     cli();
8405     for(;;)
8406       ;
8407   }
8408 
8409   if(c == BACKSPACE){
8410     uartputc('\b'); uartputc(' '); uartputc('\b');
8411   } else
8412     uartputc(c);
8413 
8414   if(c == -10000)
8415   cgaputc(c);
8416 }
8417 
8418 #define INPUT_BUF 128
8419 struct {
8420   char buf[INPUT_BUF];
8421   uint r;  
8422   uint w;  
8423   uint e;  
8424 } input;
8425 
8426 #define C(x)  ((x)-'@')  
8427 
8428 void
8429 consoleintr(int (*getc)(void))
8430 {
8431   int c, doprocdump = 0;
8432 
8433   acquire(&cons.lock);
8434   while((c = getc()) >= 0){
8435     switch(c){
8436     case C('P'):  
8437       
8438       doprocdump = 1;
8439       break;
8440     case C('U'):  
8441       while(input.e != input.w &&
8442             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8443         input.e--;
8444         consputc(BACKSPACE);
8445       }
8446       break;
8447     case C('H'): case '\x7f':  
8448       if(input.e != input.w){
8449         input.e--;
8450         consputc(BACKSPACE);
8451       }
8452       break;
8453     default:
8454       if(c != 0 && input.e-input.r < INPUT_BUF){
8455         c = (c == '\r') ? '\n' : c;
8456         input.buf[input.e++ % INPUT_BUF] = c;
8457         consputc(c);
8458         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8459           input.w = input.e;
8460           wakeup(&input.r);
8461         }
8462       }
8463       break;
8464     }
8465   }
8466   release(&cons.lock);
8467   if(doprocdump) {
8468     procdump();  
8469   }
8470 }
8471 
8472 int
8473 consoleread(struct inode *ip, char *dst, int n)
8474 {
8475   uint target;
8476   int c;
8477 
8478   iunlock(ip);
8479   target = n;
8480   acquire(&cons.lock);
8481   while(n > 0){
8482     while(input.r == input.w){
8483       if(myproc()->killed){
8484         release(&cons.lock);
8485         ilock(ip);
8486         return -1;
8487       }
8488       sleep(&input.r, &cons.lock);
8489     }
8490     c = input.buf[input.r++ % INPUT_BUF];
8491     if(c == C('D')){  
8492       if(n < target){
8493         
8494         
8495         input.r--;
8496       }
8497       break;
8498     }
8499     *dst++ = c;
8500     --n;
8501     if(c == '\n')
8502       break;
8503   }
8504   release(&cons.lock);
8505   ilock(ip);
8506 
8507   return target - n;
8508 }
8509 
8510 int
8511 consolewrite(struct inode *ip, char *buf, int n)
8512 {
8513   int i;
8514 
8515   iunlock(ip);
8516   acquire(&cons.lock);
8517   for(i = 0; i < n; i++)
8518     consputc(buf[i] & 0xff);
8519   release(&cons.lock);
8520   ilock(ip);
8521 
8522   return n;
8523 }
8524 
8525 void
8526 consoleinit(void)
8527 {
8528   initlock(&cons.lock, "console");
8529 
8530   devsw[CONSOLE].write = consolewrite;
8531   devsw[CONSOLE].read = consoleread;
8532   cons.locking = 1;
8533 
8534   
8535 }
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 
8552 #include "types.h"
8553 #include "defs.h"
8554 #include "param.h"
8555 #include "traps.h"
8556 #include "spinlock.h"
8557 #include "sleeplock.h"
8558 #include "fs.h"
8559 #include "file.h"
8560 #include "mmu.h"
8561 #include "proc.h"
8562 #include "riscv.h"
8563 
8564 #define COM1    0x3f8
8565 
8566 static int uart;    
8567 
8568 void
8569 uartinit(void)
8570 {
8571   char *p;
8572 
8573   
8574   outb(COM1+2, 0);
8575 
8576   
8577   outb(COM1+3, 0x80);    
8578   outb(COM1+0, 115200/9600);
8579   outb(COM1+1, 0);
8580   outb(COM1+3, 0x03);    
8581   outb(COM1+4, 0);
8582   outb(COM1+1, 0x01);    
8583 
8584   
8585   if(inb(COM1+5) == 0xFF)
8586     return;
8587   uart = 1;
8588 
8589   
8590   
8591   inb(COM1+2);
8592   inb(COM1+0);
8593   
8594 
8595   
8596   for(p="xv6...\n"; *p; p++)
8597     uartputc(*p);
8598 }
8599 
8600 void
8601 uartputc(int c)
8602 {
8603   int i;
8604 
8605   if(!uart)
8606     return;
8607   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8608     microdelay(10);
8609   outb(COM1+0, c);
8610 }
8611 
8612 static int
8613 uartgetc(void)
8614 {
8615   if(!uart)
8616     return -1;
8617   if(!(inb(COM1+5) & 0x01))
8618     return -1;
8619   return inb(COM1+0);
8620 }
8621 
8622 void
8623 uartintr(void)
8624 {
8625   consoleintr(uartgetc);
8626 }
8627 
8628 
8629 
8630 
8631 
8632 
8633 
8634 
8635 
8636 
8637 
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 
8651 
8652 
8653 
8654 
8655 
8656 
8657 
8658 /*
8659 .globl start
8660 start:
8661   pushl $argv
8662   pushl $init
8663   pushl $0  
8664   movl $SYS_exec, %eax
8665   int $T_SYSCALL
8666 
8667 
8668 exit:
8669   movl $SYS_exit, %eax
8670   int $T_SYSCALL
8671   jmp exit
8672 */
8673 .globl start
8674 start:
8675 	addi sp, sp,-12
8676 	la	 t0, argv
8677 	sw	 t0, 8(sp)
8678 	la	 t1, init
8679 	sw	 t1, 4(sp)
8680 	sw	 zero, 0(sp)
8681 	li	 a0, SYS_exec
8682 	ecall
8683 
8684 exit:
8685 	li	 a0, SYS_exec
8686 	ecall
8687 	j 	 exit
8688 
8689 
8690 init:
8691   .string "/init\0"
8692 
8693 
8694 
8695 .p2align 4
8696 argv:
8697   .long init
8698   .long 0
8699 
8700 
8701 
8702 
8703 /*
8704 
8705   .globl name; \
8706   name: \
8707     movl $SYS_ 
8708     int $T_SYSCALL; \
8709     ret
8710 */
8711 
8712 
8713   .globl name; \
8714   name: \
8715 	addi sp,sp,-4; \
8716 	sw zero,0(sp); \
8717     li a0,SYS_ 
8718     ecall;	\
8719 	addi sp,sp,4; \
8720     ret;
8721 
8722 
8723   .globl name; \
8724   name: \
8725 	addi sp,sp,-8; \
8726 	sw a0,4(sp); \
8727 	sw zero,0(sp); \
8728     li a0,SYS_ 
8729     ecall;	\
8730 	addi sp,sp,8; \
8731     ret
8732 
8733 
8734   .globl name; \
8735   name: \
8736 	addi sp,sp,-12; \
8737 	sw a1,8(sp); \
8738 	sw a0,4(sp); \
8739 	sw zero,0(sp); \
8740     li a0,SYS_ 
8741     ecall;	\
8742 	addi sp,sp,12; \
8743     ret
8744 
8745 
8746   .globl name; \
8747   name: \
8748 	addi sp,sp,-16; \
8749 	sw a2,12(sp); \
8750 	sw a1,8(sp); \
8751 	sw a0,4(sp); \
8752 	sw zero,0(sp); \
8753     li a0,SYS_ 
8754     ecall;	\
8755 	addi sp,sp,16; \
8756     ret
8757 
8758 SYSCALL_arg0(fork)
8759 SYSCALL_arg0(exit)
8760 SYSCALL_arg0(wait)
8761 SYSCALL_arg1(pipe)
8762 SYSCALL_arg3(read)
8763 SYSCALL_arg3(write)
8764 SYSCALL_arg1(close)
8765 SYSCALL_arg1(kill)
8766 SYSCALL_arg2(exec)
8767 SYSCALL_arg2(open)
8768 SYSCALL_arg3(mknod)
8769 SYSCALL_arg1(unlink)
8770 SYSCALL_arg2(fstat)
8771 SYSCALL_arg2(link)
8772 SYSCALL_arg1(mkdir)
8773 SYSCALL_arg1(chdir)
8774 SYSCALL_arg1(dup)
8775 SYSCALL_arg0(getpid)
8776 SYSCALL_arg1(sbrk)
8777 SYSCALL_arg1(sleep)
8778 SYSCALL_arg0(uptime)
8779 /*
8780 
8781   .globl name; \
8782   name: \
8783     li a0,SYS_ 
8784     ecall;
8785     mret
8786 SYSCALL(fork)
8787 SYSCALL(exit)
8788 SYSCALL(wait)
8789 SYSCALL(pipe)
8790 SYSCALL(read)
8791 SYSCALL(write)
8792 SYSCALL(close)
8793 SYSCALL(kill)
8794 SYSCALL(exec)
8795 SYSCALL(open)
8796 SYSCALL(mknod)
8797 SYSCALL(unlink)
8798 SYSCALL(fstat)
8799 SYSCALL(link)
8800 SYSCALL(mkdir)
8801 SYSCALL(chdir)
8802 SYSCALL(dup)
8803 SYSCALL(getpid)
8804 SYSCALL(sbrk)
8805 SYSCALL(sleep)
8806 SYSCALL(uptime)
8807 */
8808 
8809 
8810 
8811 
8812 
8813 
8814 
8815 
8816 
8817 
8818 
8819 
8820 
8821 
8822 
8823 
8824 
8825 
8826 
8827 
8828 
8829 
8830 
8831 
8832 
8833 
8834 
8835 
8836 
8837 
8838 
8839 
8840 
8841 
8842 
8843 
8844 
8845 
8846 
8847 
8848 
8849 
8850 
8851 
8852 #include "types.h"
8853 #include "stat.h"
8854 #include "user.h"
8855 #include "fcntl.h"
8856 
8857 char *argv[] = { "sh", 0 };
8858 
8859 int
8860 main(void)
8861 {
8862   int pid, wpid;
8863 
8864   if(open("console", O_RDWR) < 0){
8865     mknod("console", 1, 1);
8866     open("console", O_RDWR);
8867   }
8868   dup(0);  
8869   dup(0);  
8870 
8871   for(;;){
8872     printf(1, "init: starting sh\n");
8873     pid = fork();
8874     if(pid < 0){
8875       printf(1, "init: fork failed\n");
8876       exit();
8877     }
8878     if(pid == 0){
8879       exec("sh", argv);
8880       printf(1, "init: exec sh failed\n");
8881       exit();
8882     }
8883     while((wpid=wait()) >= 0 && wpid != pid)
8884       printf(1, "zombie!\n");
8885   }
8886 }
8887 
8888 
8889 
8890 
8891 
8892 
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 
8901 
8902 #include "types.h"
8903 #include "user.h"
8904 #include "fcntl.h"
8905 
8906 
8907 #define EXEC  1
8908 #define REDIR 2
8909 #define PIPE  3
8910 #define LIST  4
8911 #define BACK  5
8912 
8913 #define MAXARGS 10
8914 
8915 struct cmd {
8916   int type;
8917 };
8918 
8919 struct execcmd {
8920   int type;
8921   char *argv[MAXARGS];
8922   char *eargv[MAXARGS];
8923 };
8924 
8925 struct redircmd {
8926   int type;
8927   struct cmd *cmd;
8928   char *file;
8929   char *efile;
8930   int mode;
8931   int fd;
8932 };
8933 
8934 struct pipecmd {
8935   int type;
8936   struct cmd *left;
8937   struct cmd *right;
8938 };
8939 
8940 struct listcmd {
8941   int type;
8942   struct cmd *left;
8943   struct cmd *right;
8944 };
8945 
8946 struct backcmd {
8947   int type;
8948   struct cmd *cmd;
8949 };
8950 int fork1(void);  
8951 void panic(char*);
8952 struct cmd *parsecmd(char*);
8953 
8954 
8955 void
8956 runcmd(struct cmd *cmd)
8957 {
8958   int p[2];
8959   struct backcmd *bcmd;
8960   struct execcmd *ecmd;
8961   struct listcmd *lcmd;
8962   struct pipecmd *pcmd;
8963   struct redircmd *rcmd;
8964 
8965   if(cmd == 0)
8966     exit();
8967 
8968   switch(cmd->type){
8969   default:
8970     panic("runcmd");
8971 
8972   case EXEC:
8973     ecmd = (struct execcmd*)cmd;
8974     if(ecmd->argv[0] == 0)
8975       exit();
8976     exec(ecmd->argv[0], ecmd->argv);
8977     printf(2, "exec %s failed\n", ecmd->argv[0]);
8978     break;
8979 
8980   case REDIR:
8981     rcmd = (struct redircmd*)cmd;
8982     close(rcmd->fd);
8983     if(open(rcmd->file, rcmd->mode) < 0){
8984       printf(2, "open %s failed\n", rcmd->file);
8985       exit();
8986     }
8987     runcmd(rcmd->cmd);
8988     break;
8989 
8990   case LIST:
8991     lcmd = (struct listcmd*)cmd;
8992     if(fork1() == 0)
8993       runcmd(lcmd->left);
8994     wait();
8995     runcmd(lcmd->right);
8996     break;
8997 
8998 
8999 
9000   case PIPE:
9001     pcmd = (struct pipecmd*)cmd;
9002     if(pipe(p) < 0)
9003       panic("pipe");
9004     if(fork1() == 0){
9005       close(1);
9006       dup(p[1]);
9007       close(p[0]);
9008       close(p[1]);
9009       runcmd(pcmd->left);
9010     }
9011     if(fork1() == 0){
9012       close(0);
9013       dup(p[0]);
9014       close(p[0]);
9015       close(p[1]);
9016       runcmd(pcmd->right);
9017     }
9018     close(p[0]);
9019     close(p[1]);
9020     wait();
9021     wait();
9022     break;
9023 
9024   case BACK:
9025     bcmd = (struct backcmd*)cmd;
9026     if(fork1() == 0)
9027       runcmd(bcmd->cmd);
9028     break;
9029   }
9030   exit();
9031 }
9032 
9033 int
9034 getcmd(char *buf, int nbuf)
9035 {
9036   printf(2, "$ ");
9037   memset(buf, 0, nbuf);
9038   gets(buf, nbuf);
9039   if(buf[0] == 0) 
9040     return -1;
9041   return 0;
9042 }
9043 
9044 
9045 
9046 
9047 
9048 
9049 
9050 int
9051 main(void)
9052 {
9053   static char buf[100];
9054   int fd;
9055 
9056   
9057   while((fd = open("console", O_RDWR)) >= 0){
9058     if(fd >= 3){
9059       close(fd);
9060       break;
9061     }
9062   }
9063 
9064   
9065   while(getcmd(buf, sizeof(buf)) >= 0){
9066     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
9067       
9068       buf[strlen(buf)-1] = 0;  
9069       if(chdir(buf+3) < 0)
9070         printf(2, "cannot cd %s\n", buf+3);
9071       continue;
9072     }
9073     if(fork1() == 0)
9074       runcmd(parsecmd(buf));
9075     wait();
9076   }
9077   exit();
9078 }
9079 
9080 void
9081 panic(char *s)
9082 {
9083   printf(2, "%s\n", s);
9084   exit();
9085 }
9086 
9087 int
9088 fork1(void)
9089 {
9090   int pid;
9091 
9092   pid = fork();
9093   if(pid == -1)
9094     panic("fork");
9095   return pid;
9096 }
9097 
9098 
9099 
9100 
9101 
9102 struct cmd*
9103 execcmd(void)
9104 {
9105   struct execcmd *cmd;
9106 
9107   cmd = malloc(sizeof(*cmd));
9108   memset(cmd, 0, sizeof(*cmd));
9109   cmd->type = EXEC;
9110   return (struct cmd*)cmd;
9111 }
9112 
9113 struct cmd*
9114 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
9115 {
9116   struct redircmd *cmd;
9117 
9118   cmd = malloc(sizeof(*cmd));
9119   memset(cmd, 0, sizeof(*cmd));
9120   cmd->type = REDIR;
9121   cmd->cmd = subcmd;
9122   cmd->file = file;
9123   cmd->efile = efile;
9124   cmd->mode = mode;
9125   cmd->fd = fd;
9126   return (struct cmd*)cmd;
9127 }
9128 
9129 struct cmd*
9130 pipecmd(struct cmd *left, struct cmd *right)
9131 {
9132   struct pipecmd *cmd;
9133 
9134   cmd = malloc(sizeof(*cmd));
9135   memset(cmd, 0, sizeof(*cmd));
9136   cmd->type = PIPE;
9137   cmd->left = left;
9138   cmd->right = right;
9139   return (struct cmd*)cmd;
9140 }
9141 
9142 
9143 
9144 
9145 
9146 
9147 
9148 
9149 
9150 struct cmd*
9151 listcmd(struct cmd *left, struct cmd *right)
9152 {
9153   struct listcmd *cmd;
9154 
9155   cmd = malloc(sizeof(*cmd));
9156   memset(cmd, 0, sizeof(*cmd));
9157   cmd->type = LIST;
9158   cmd->left = left;
9159   cmd->right = right;
9160   return (struct cmd*)cmd;
9161 }
9162 
9163 struct cmd*
9164 backcmd(struct cmd *subcmd)
9165 {
9166   struct backcmd *cmd;
9167 
9168   cmd = malloc(sizeof(*cmd));
9169   memset(cmd, 0, sizeof(*cmd));
9170   cmd->type = BACK;
9171   cmd->cmd = subcmd;
9172   return (struct cmd*)cmd;
9173 }
9174 
9175 
9176 
9177 
9178 
9179 
9180 
9181 
9182 
9183 
9184 
9185 
9186 
9187 
9188 
9189 
9190 
9191 
9192 
9193 
9194 
9195 
9196 
9197 
9198 
9199 
9200 
9201 
9202 char whitespace[] = " \t\r\n\v";
9203 char symbols[] = "<|>&;()";
9204 
9205 int
9206 gettoken(char **ps, char *es, char **q, char **eq)
9207 {
9208   char *s;
9209   int ret;
9210 
9211   s = *ps;
9212   while(s < es && strchr(whitespace, *s))
9213     s++;
9214   if(q)
9215     *q = s;
9216   ret = *s;
9217   switch(*s){
9218   case 0:
9219     break;
9220   case '|':
9221   case '(':
9222   case ')':
9223   case ';':
9224   case '&':
9225   case '<':
9226     s++;
9227     break;
9228   case '>':
9229     s++;
9230     if(*s == '>'){
9231       ret = '+';
9232       s++;
9233     }
9234     break;
9235   default:
9236     ret = 'a';
9237     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
9238       s++;
9239     break;
9240   }
9241   if(eq)
9242     *eq = s;
9243 
9244   while(s < es && strchr(whitespace, *s))
9245     s++;
9246   *ps = s;
9247   return ret;
9248 }
9249 
9250 int
9251 peek(char **ps, char *es, char *toks)
9252 {
9253   char *s;
9254 
9255   s = *ps;
9256   while(s < es && strchr(whitespace, *s))
9257     s++;
9258   *ps = s;
9259   return *s && strchr(toks, *s);
9260 }
9261 
9262 struct cmd *parseline(char**, char*);
9263 struct cmd *parsepipe(char**, char*);
9264 struct cmd *parseexec(char**, char*);
9265 struct cmd *nulterminate(struct cmd*);
9266 
9267 struct cmd*
9268 parsecmd(char *s)
9269 {
9270   char *es;
9271   struct cmd *cmd;
9272 
9273   es = s + strlen(s);
9274   cmd = parseline(&s, es);
9275   peek(&s, es, "");
9276   if(s != es){
9277     printf(2, "leftovers: %s\n", s);
9278     panic("syntax");
9279   }
9280   nulterminate(cmd);
9281   return cmd;
9282 }
9283 
9284 struct cmd*
9285 parseline(char **ps, char *es)
9286 {
9287   struct cmd *cmd;
9288 
9289   cmd = parsepipe(ps, es);
9290   while(peek(ps, es, "&")){
9291     gettoken(ps, es, 0, 0);
9292     cmd = backcmd(cmd);
9293   }
9294   if(peek(ps, es, ";")){
9295     gettoken(ps, es, 0, 0);
9296     cmd = listcmd(cmd, parseline(ps, es));
9297   }
9298   return cmd;
9299 }
9300 struct cmd*
9301 parsepipe(char **ps, char *es)
9302 {
9303   struct cmd *cmd;
9304 
9305   cmd = parseexec(ps, es);
9306   if(peek(ps, es, "|")){
9307     gettoken(ps, es, 0, 0);
9308     cmd = pipecmd(cmd, parsepipe(ps, es));
9309   }
9310   return cmd;
9311 }
9312 
9313 struct cmd*
9314 parseredirs(struct cmd *cmd, char **ps, char *es)
9315 {
9316   int tok;
9317   char *q, *eq;
9318 
9319   while(peek(ps, es, "<>")){
9320     tok = gettoken(ps, es, 0, 0);
9321     if(gettoken(ps, es, &q, &eq) != 'a')
9322       panic("missing file for redirection");
9323     switch(tok){
9324     case '<':
9325       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9326       break;
9327     case '>':
9328       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9329       break;
9330     case '+':  
9331       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9332       break;
9333     }
9334   }
9335   return cmd;
9336 }
9337 
9338 
9339 
9340 
9341 
9342 
9343 
9344 
9345 
9346 
9347 
9348 
9349 
9350 struct cmd*
9351 parseblock(char **ps, char *es)
9352 {
9353   struct cmd *cmd;
9354 
9355   if(!peek(ps, es, "("))
9356     panic("parseblock");
9357   gettoken(ps, es, 0, 0);
9358   cmd = parseline(ps, es);
9359   if(!peek(ps, es, ")"))
9360     panic("syntax - missing )");
9361   gettoken(ps, es, 0, 0);
9362   cmd = parseredirs(cmd, ps, es);
9363   return cmd;
9364 }
9365 
9366 struct cmd*
9367 parseexec(char **ps, char *es)
9368 {
9369   char *q, *eq;
9370   int tok, argc;
9371   struct execcmd *cmd;
9372   struct cmd *ret;
9373 
9374   if(peek(ps, es, "("))
9375     return parseblock(ps, es);
9376 
9377   ret = execcmd();
9378   cmd = (struct execcmd*)ret;
9379 
9380   argc = 0;
9381   ret = parseredirs(ret, ps, es);
9382   while(!peek(ps, es, "|)&;")){
9383     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9384       break;
9385     if(tok != 'a')
9386       panic("syntax");
9387     cmd->argv[argc] = q;
9388     cmd->eargv[argc] = eq;
9389     argc++;
9390     if(argc >= MAXARGS)
9391       panic("too many args");
9392     ret = parseredirs(ret, ps, es);
9393   }
9394   cmd->argv[argc] = 0;
9395   cmd->eargv[argc] = 0;
9396   return ret;
9397 }
9398 
9399 
9400 
9401 struct cmd*
9402 nulterminate(struct cmd *cmd)
9403 {
9404   int i;
9405   struct backcmd *bcmd;
9406   struct execcmd *ecmd;
9407   struct listcmd *lcmd;
9408   struct pipecmd *pcmd;
9409   struct redircmd *rcmd;
9410 
9411   if(cmd == 0)
9412     return 0;
9413 
9414   switch(cmd->type){
9415   case EXEC:
9416     ecmd = (struct execcmd*)cmd;
9417     for(i=0; ecmd->argv[i]; i++)
9418       *ecmd->eargv[i] = 0;
9419     break;
9420 
9421   case REDIR:
9422     rcmd = (struct redircmd*)cmd;
9423     nulterminate(rcmd->cmd);
9424     *rcmd->efile = 0;
9425     break;
9426 
9427   case PIPE:
9428     pcmd = (struct pipecmd*)cmd;
9429     nulterminate(pcmd->left);
9430     nulterminate(pcmd->right);
9431     break;
9432 
9433   case LIST:
9434     lcmd = (struct listcmd*)cmd;
9435     nulterminate(lcmd->left);
9436     nulterminate(lcmd->right);
9437     break;
9438 
9439   case BACK:
9440     bcmd = (struct backcmd*)cmd;
9441     nulterminate(bcmd->cmd);
9442     break;
9443   }
9444   return cmd;
9445 }
9446 
9447 
9448 
9449 
9450 
9451 
9452 
9453 
9454 
9455 
9456 
9457 
9458 
9459 
9460 .globl start
9461 start:
9462   la    sp, start
9463   j    bootmain
9464 
9465 
9466 
9467 
9468 
9469 
9470 
9471 
9472 
9473 
9474 
9475 
9476 
9477 
9478 
9479 
9480 
9481 
9482 
9483 
9484 
9485 
9486 
9487 
9488 
9489 
9490 
9491 
9492 
9493 
9494 
9495 
9496 
9497 
9498 
9499 
9500 
9501 
9502 
9503 
9504 
9505 
9506 
9507 #include "types.h"
9508 #include "elf.h"
9509 #include "riscv.h"
9510 #include "memlayout.h"
9511 
9512 #define SECTSIZE  512
9513 
9514 void readseg(uchar*, uint, uint);
9515 
9516 void
9517 bootmain(void)
9518 {
9519   struct elfhdr *elf;
9520   struct proghdr *ph, *eph;
9521   void (*entry)(void);
9522   uchar* pa;
9523 
9524   elf = (struct elfhdr*)0x10000;  
9525 
9526   
9527   readseg((uchar*)elf, 4096, 0);
9528 
9529   
9530   if(elf->magic != ELF_MAGIC)
9531     return;  
9532   
9533   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9534   eph = ph + elf->phnum;
9535   for(; ph < eph; ph++){
9536     pa = (uchar*)ph->paddr;
9537     readseg(pa, ph->filesz, ph->off);
9538     if(ph->memsz > ph->filesz)
9539       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9540   }
9541   
9542   
9543 
9544   entry = (void(*)(void))(elf->entry);
9545   
9546   
9547   entry();
9548 }
9549 
9550 void
9551 waitdisk(void)
9552 {
9553   
9554   while((inb(0x1F7) & 0xC0) != 0x40)
9555     ;
9556 }
9557 
9558 
9559 void
9560 readsect(void *dst, uint offset)
9561 {
9562   
9563   
9564   outb(0x1F2, 1);   
9565 
9566   outb(0x1F3, offset);
9567   outb(0x1F4, offset >> 8);
9568   outb(0x1F5, offset >> 16);
9569   
9570   outb(0x1F6, (offset >> 24));
9571 
9572   
9573   outb(0x1F7, 0x20);  
9574 
9575   
9576   waitdisk();
9577   
9578   insl(0x1F0, dst, SECTSIZE);
9579 }
9580 
9581 
9582 
9583 void
9584 readseg(uchar* pa, uint count, uint offset)
9585 {
9586 
9587 
9588 
9589 
9590 
9591 
9592   uchar* epa;
9593 
9594   epa = pa + count;
9595 
9596   
9597   pa -= offset % SECTSIZE;
9598 
9599 
9600   
9601   offset = (offset / SECTSIZE) + 1;
9602 /*
9603 	int* addr = (int*)(0x1E4 + RISCV_IO_BASE);
9604 	*addr = (int)pa;
9605 	addr++;
9606 	*addr = offset;
9607 	addr++;
9608 	*addr = count;
9609 
9610 	char* read = (char*)(0x1E3 + RISCV_IO_BASE);
9611 	*read = 1;
9612 */
9613   
9614   
9615   
9616   for(; pa < epa; pa += SECTSIZE, offset++)
9617     readsect(pa, offset);
9618 }
9619 
9620 
9621 
9622 
9623 
9624 
9625 
9626 
9627 
9628 
9629 
9630 
9631 
9632 
9633 
9634 
9635 
9636 
9637 
9638 
9639 
9640 
9641 
9642 
9643 
9644 
9645 
9646 
9647 
9648 
9649 
